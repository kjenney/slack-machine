{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Slack Machine Slack Machine is a sexy, simple, yet powerful and extendable Slack bot. More than just a bot, Slack Machine is a framework that helps you develop your Slack workspace into a ChatOps powerhouse. Note As of v0.26.0 Slack Machine supports AsyncIO using the Slack Events API and Socket Mode . This is still experimental and should be thoroughly tested. The goal is to eventually stop supporting the old version that uses the Slack RTM API, as the Events API is recommended by Slack for must use cases and asyncio has the potential to be much more performant. I encourage everyone to start testing the async mode and report any issues in this repository. Features Get started with mininal configuration Built on top of the Slack RTM API for smooth, real-time interactions (or Slack Events API + Socket Mode for async mode) Support for rich interactions using the Slack Web API High-level API for maximum convenience when building plugins Low-level API for maximum flexibility (Experimental) Support for asyncio Plugin API features: Listen and respond to any regular expression Capture parts of messages to use as variables in your functions Respond to messages in channels, groups and direct message conversations Respond with reactions Respond in threads Respond with ephemeral messages Send DMs to any user Support for message attachments Support for blocks Listen and respond to any Slack event supported by the RTM API (or the Events API with Socket Mode in the case of using async mode) Store and retrieve any kind of data in persistent storage (currently Redis and in-memory storage are supported) Schedule actions and messages (note: currently not supported in async mode) Emit and listen for events Help texts for Plugins Built in web server for webhooks (note: currently not supported in async mode) Coming Soon Support for Interactive Buttons ... and much more","title":"Slack Machine"},{"location":"#slack-machine","text":"Slack Machine is a sexy, simple, yet powerful and extendable Slack bot. More than just a bot, Slack Machine is a framework that helps you develop your Slack workspace into a ChatOps powerhouse.","title":"Slack Machine"},{"location":"#note","text":"As of v0.26.0 Slack Machine supports AsyncIO using the Slack Events API and Socket Mode . This is still experimental and should be thoroughly tested. The goal is to eventually stop supporting the old version that uses the Slack RTM API, as the Events API is recommended by Slack for must use cases and asyncio has the potential to be much more performant. I encourage everyone to start testing the async mode and report any issues in this repository.","title":"Note"},{"location":"#features","text":"Get started with mininal configuration Built on top of the Slack RTM API for smooth, real-time interactions (or Slack Events API + Socket Mode for async mode) Support for rich interactions using the Slack Web API High-level API for maximum convenience when building plugins Low-level API for maximum flexibility (Experimental) Support for asyncio","title":"Features"},{"location":"#plugin-api-features","text":"Listen and respond to any regular expression Capture parts of messages to use as variables in your functions Respond to messages in channels, groups and direct message conversations Respond with reactions Respond in threads Respond with ephemeral messages Send DMs to any user Support for message attachments Support for blocks Listen and respond to any Slack event supported by the RTM API (or the Events API with Socket Mode in the case of using async mode) Store and retrieve any kind of data in persistent storage (currently Redis and in-memory storage are supported) Schedule actions and messages (note: currently not supported in async mode) Emit and listen for events Help texts for Plugins Built in web server for webhooks (note: currently not supported in async mode)","title":"Plugin API features:"},{"location":"#coming-soon","text":"Support for Interactive Buttons ... and much more","title":"Coming Soon"},{"location":"async/","text":"Async mode As of v0.26.0 Slack Machine supports AsyncIO using the Slack Events API and Socket Mode . This is still experimental and should be thoroughly tested. The goal is to eventually stop supporting the old version that uses the Slack RTM API, as the Events API is recommended by Slack for must use cases and asyncio has the potential to be much more performant. All the asyncio code is in the machine.asyncio package. The async version of Slack Machine has been built from the ground up. It is AsyncIO from top to bottom and is fully type-hinted (and checked with MyPY) How to start using it With the advent of asyncio in Slack Machine, we're also moving towards using Slack Apps instead of legacy bot tokens. This means that you'll need to create a new app in Slack and get an app token and a bot token for it: Create a new app in Slack: https://api.slack.com/apps Choose to create an app from an App manifest Copy/paste the following manifest: manifest.yaml display_information: name: Slack Machine features: bot_user: display_name: Slack Machine always_online: false oauth_config: scopes: bot: - app_mentions:read - channels:history - channels:join - channels:read - chat:write - chat:write.public - emoji:read - groups:history - groups:read - groups:write - im:history - im:read - im:write - mpim:history - mpim:read - mpim:write - pins:read - pins:write - reactions:read - reactions:write - users:read - users:read.email - channels:manage - chat:write.customize - dnd:read - files:read - files:write - links:read - links:write - metadata.message:read - usergroups:read - usergroups:write - users.profile:read - users:write settings: event_subscriptions: bot_events: - app_mention - channel_archive - channel_created - channel_deleted - channel_id_changed - channel_left - channel_rename - channel_unarchive - group_archive - group_deleted - group_left - group_rename - group_unarchive - member_joined_channel - member_left_channel - message.channels - message.groups - message.im - message.mpim - reaction_added - reaction_removed - team_join - user_change - user_profile_changed - user_status_changed interactivity: is_enabled: true org_deploy_enabled: false socket_mode_enabled: true token_rotation_enabled: false Add the Slack App and Bot tokens to your local_settings.py like this: local_settings.py SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" Start the bot with slack-machine-async ... Profit! Choosing storage As Async mode is fully built on AsyncIO, it uses different storage backends then the old sync mode. The following 2 backends are available: machine.asyncio.storage.backends.memory.MemoryStorage machine.asyncio.storage.backends.memory.RedisStorage Plugin API and usage To support asyncio, the plugin API is slightly different. All user-defined plugin methods (the methods that are marked with the plugin decorators ) should now be defined as async def . And all builtin plugin methods are async as well. This also means that the builtin plugins have async versions: machine.asyncio.plugins.builtin.general.HelloPlugin , machine.asyncio.plugins.builtin.general.PingPongPlugin , machine.asyncio.plugins.builtin.help.HelpPlugin , machine.asyncio.plugins.builtin.fun.images.ImageSearchPlugin , machine.asyncio.plugins.builtin.fun.memes.MemePlugin , machine.asyncio.plugins.builtin.admin.RBACPlugin","title":"Async mode"},{"location":"async/#async-mode","text":"As of v0.26.0 Slack Machine supports AsyncIO using the Slack Events API and Socket Mode . This is still experimental and should be thoroughly tested. The goal is to eventually stop supporting the old version that uses the Slack RTM API, as the Events API is recommended by Slack for must use cases and asyncio has the potential to be much more performant. All the asyncio code is in the machine.asyncio package. The async version of Slack Machine has been built from the ground up. It is AsyncIO from top to bottom and is fully type-hinted (and checked with MyPY)","title":"Async mode"},{"location":"async/#how-to-start-using-it","text":"With the advent of asyncio in Slack Machine, we're also moving towards using Slack Apps instead of legacy bot tokens. This means that you'll need to create a new app in Slack and get an app token and a bot token for it: Create a new app in Slack: https://api.slack.com/apps Choose to create an app from an App manifest Copy/paste the following manifest: manifest.yaml display_information: name: Slack Machine features: bot_user: display_name: Slack Machine always_online: false oauth_config: scopes: bot: - app_mentions:read - channels:history - channels:join - channels:read - chat:write - chat:write.public - emoji:read - groups:history - groups:read - groups:write - im:history - im:read - im:write - mpim:history - mpim:read - mpim:write - pins:read - pins:write - reactions:read - reactions:write - users:read - users:read.email - channels:manage - chat:write.customize - dnd:read - files:read - files:write - links:read - links:write - metadata.message:read - usergroups:read - usergroups:write - users.profile:read - users:write settings: event_subscriptions: bot_events: - app_mention - channel_archive - channel_created - channel_deleted - channel_id_changed - channel_left - channel_rename - channel_unarchive - group_archive - group_deleted - group_left - group_rename - group_unarchive - member_joined_channel - member_left_channel - message.channels - message.groups - message.im - message.mpim - reaction_added - reaction_removed - team_join - user_change - user_profile_changed - user_status_changed interactivity: is_enabled: true org_deploy_enabled: false socket_mode_enabled: true token_rotation_enabled: false Add the Slack App and Bot tokens to your local_settings.py like this: local_settings.py SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" Start the bot with slack-machine-async ... Profit!","title":"How to start using it"},{"location":"async/#choosing-storage","text":"As Async mode is fully built on AsyncIO, it uses different storage backends then the old sync mode. The following 2 backends are available: machine.asyncio.storage.backends.memory.MemoryStorage machine.asyncio.storage.backends.memory.RedisStorage","title":"Choosing storage"},{"location":"async/#plugin-api-and-usage","text":"To support asyncio, the plugin API is slightly different. All user-defined plugin methods (the methods that are marked with the plugin decorators ) should now be defined as async def . And all builtin plugin methods are async as well. This also means that the builtin plugins have async versions: machine.asyncio.plugins.builtin.general.HelloPlugin , machine.asyncio.plugins.builtin.general.PingPongPlugin , machine.asyncio.plugins.builtin.help.HelpPlugin , machine.asyncio.plugins.builtin.fun.images.ImageSearchPlugin , machine.asyncio.plugins.builtin.fun.memes.MemePlugin , machine.asyncio.plugins.builtin.admin.RBACPlugin","title":"Plugin API and usage"},{"location":"api/","text":"API Documentation This is the API documentation of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented. Plugin classes The following 2 classes form the basis for Plugin development. machine.plugins.base.MachineBasePlugin Base class for all Slack Machine plugins The purpose of this class is two-fold: It acts as a marker-class so Slack Machine can recognize plugins as such It provides a lot of common functionality and convenience methods for plugins to interact with channels and users Attributes: Name Type Description settings Slack Machine settings object that contains all settings that were defined through local_settings.py Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. Source code in machine/plugins/base.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 class MachineBasePlugin : \"\"\"Base class for all Slack Machine plugins The purpose of this class is two-fold: 1. It acts as a marker-class so Slack Machine can recognize plugins as such 2. It provides a lot of common functionality and convenience methods for plugins to interact with channels and users :var settings: Slack Machine settings object that contains all settings that were defined through ``local_settings.py`` Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. \"\"\" def __init__ ( self , client : SlackClient , settings : CaseInsensitiveDict , storage : PluginStorage ): self . _client = client self . storage = storage self . settings = settings self . _fq_name = f \" { self . __module__ } . { self . __class__ . __name__ } \" def init ( self ): \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass @property def users ( self ) -> Dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users @property def channels ( self ) -> Dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels def find_channel_by_name ( self , channel_name : str ) -> Optional [ Channel ]: \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c @property def bot_info ( self ) -> Dict [ str , str ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () def say ( self , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def say_scheduled ( self , when : datetime , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional :py:class:`~machine.models.user.User` object or id of user if the message needs to visible to that specific user only :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def react ( self , channel : Union [ Channel , str ], ts : str , emoji : str ): \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( channel , ts , emoji ) def send_dm ( self , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) def send_dm_scheduled ( self , when : datetime , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs ) def emit ( self , event : str , ** kwargs ): \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" e = signal ( event ) e . send ( self , ** kwargs ) init () Initialize plugin This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via self.settings , and access storage through self.storage , but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. Returns: Type Description None Source code in machine/plugins/base.py 36 37 38 39 40 41 42 43 44 45 46 def init ( self ): \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass users () -> Dict [ str , User ] property Dictionary of all users in the Slack workspace Returns: Type Description Dict [ str , User ] a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class: ~machine.models.user.User object Source code in machine/plugins/base.py 48 49 50 51 52 53 54 55 @property def users ( self ) -> Dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users channels () -> Dict [ str , Channel ] property List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. Returns: Type Description Dict [ str , Channel ] a list of all channels in the Slack workspace, where each channel is a :py:class: ~machine.models.channel.Channel object Source code in machine/plugins/base.py 57 58 59 60 61 62 63 64 65 66 67 68 @property def channels ( self ) -> Dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels find_channel_by_name ( channel_name : str ) -> Optional [ Channel ] Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. Parameters: Name Type Description Default channel_name str The name of the channel to retrieve. required Returns: Type Description Optional [ Channel ] The channel if found, None otherwise. Source code in machine/plugins/base.py 70 71 72 73 74 75 76 77 78 79 80 def find_channel_by_name ( self , channel_name : str ) -> Optional [ Channel ]: \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c bot_info () -> Dict [ str , str ] property Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine Returns: Type Description Dict [ str , str ] Bot user Source code in machine/plugins/base.py 82 83 84 85 86 87 88 89 90 91 @property def bot_info ( self ) -> Dict [ str , str ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info at ( user : User ) -> str Create a mention of the provided user Create a mention of the provided user in the form of <@[user_id]> . This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth: ~machine.plugins.base.MachineBasePlugin.say Parameters: Name Type Description Default user User user your want to mention required Returns: Type Description str user mention Source code in machine/plugins/base.py 93 94 95 96 97 98 99 100 101 102 103 104 def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () say ( channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs ) Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral_user takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default channel Union [ Channel , str ] :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral_user Union [ User , str , None] optional user name or id if the message needs to visible to a specific user only None Returns: Type Description Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral_user is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def say ( self , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) say_scheduled ( when : datetime , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs ) Schedule a message to a channel This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required channel Union [ Channel , str ] :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral_user Union [ User , str , None] optional :py:class: ~machine.models.user.User object or id of user if the message needs to visible to that specific user only None Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def say_scheduled ( self , when : datetime , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional :py:class:`~machine.models.user.User` object or id of user if the message needs to visible to that specific user only :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) react ( channel : Union [ Channel , str ], ts : str , emoji : str ) React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. Parameters: Name Type Description Default channel Union [ Channel , str ] :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required ts str timestamp of the message to react to required emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def react ( self , channel : Union [ Channel , str ], ts : str , emoji : str ): \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( channel , ts , emoji ) send_dm ( user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs ) Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default user Union [ User , str ] :py:class: ~machine.models.user.User object or id of user to send DM to. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def send_dm ( self , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) send_dm_scheduled ( when : datetime , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs ) Schedule a Direct Message This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.send_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required user Union [ User , str ] :py:class: ~machine.models.user.User object or id of user to send DM to. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def send_dm_scheduled ( self , when : datetime , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs ) emit ( event : str , ** kwargs ) Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. Parameters: Name Type Description Default event str name of the event required kwargs any data you want to emit with the event required Returns: Type Description None Source code in machine/plugins/base.py 271 272 273 274 275 276 277 278 279 280 281 282 def emit ( self , event : str , ** kwargs ): \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" e = signal ( event ) e . send ( self , ** kwargs ) machine.plugins.base.Message A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The Message class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. Source code in machine/plugins/base.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 class Message : \"\"\"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The ``Message`` class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. \"\"\" def __init__ ( self , client : SlackClient , msg_event : Dict [ str , Any ], plugin_class_name : str ): self . _client = client self . _msg_event = msg_event self . _fq_plugin_name = plugin_class_name @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] @property def is_dm ( self ) -> bool : channel_id = self . _msg_event [ \"channel\" ] return not ( channel_id . startswith ( \"C\" ) or channel_id . startswith ( \"G\" )) @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () def say ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def say_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def reply ( self , text , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) def reply_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread and not ephemeral : return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) def reply_dm ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs ) def react ( self , emoji : str ): \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) def _create_reply ( self , text ): if not self . is_dm : return f \" { self . at_sender } : { text } \" else : return text @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] @property def in_thread ( self ): \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event def __str__ ( self ): if self . channel . is_im : message = f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in DM\" else : message = \"Message ' {} ', sent by user @ {} in channel # {} \" . format ( self . text , self . sender . profile . real_name , self . channel . name ) return message def __repr__ ( self ): return \"Message(text= {} , sender= {} , channel= {} )\" . format ( repr ( self . text ), repr ( self . sender . profile . real_name ), repr ( self . channel . name ) ) sender () -> User property The sender of the message Returns: Type Description User the User the message was sent by Source code in machine/plugins/base.py 301 302 303 304 305 306 307 @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] channel () -> Channel property The channel the message was sent to Returns: Type Description Channel the Channel the message was sent to Source code in machine/plugins/base.py 309 310 311 312 313 314 315 @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] text () -> str property The body of the actual message Returns: Type Description str the body (text) of the actual message Source code in machine/plugins/base.py 322 323 324 325 326 327 328 @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] at_sender () -> str property The sender of the message formatted as mention Returns: Type Description str a string representation of the sender of the message, formatted as mention _, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users Source code in machine/plugins/base.py 330 331 332 333 334 335 336 337 338 339 @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () say ( text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs ) Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def say ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) say_scheduled ( when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs ) Schedule a message This is the scheduled version of :py:meth: ~machine.plugins.base.Message.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def say_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) reply ( text , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs ) Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using blocks and/or attachments is possible. You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over in_thread Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def reply ( self , text , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) reply_scheduled ( when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs ) Schedule a reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply . It behaves the same, but will send the reply at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def reply_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread and not ephemeral : return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) reply_dm ( text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs ) Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def reply_dm ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) reply_dm_scheduled ( when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs ) Schedule a DM reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs ) react ( emoji : str ) React to the original message Add a reaction to the original message Parameters: Name Type Description Default emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 570 571 572 573 574 575 576 577 578 579 580 def react ( self , emoji : str ): \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) ts () -> str property The timestamp of the message Returns: Type Description str the timestamp of the message Source code in machine/plugins/base.py 588 589 590 591 592 593 594 @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] in_thread () property Is message in a thread Returns: Type Description bool Source code in machine/plugins/base.py 596 597 598 599 600 601 602 @property def in_thread ( self ): \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event Decorators These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.) machine.plugins.decorators process ( slack_event_type ) Process Slack events of a specific type This decorator will enable a Plugin method to process Slack events _ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events Parameters: Name Type Description Default slack_event_type type of event the method needs to process. Can be any event supported by the RTM API required Returns: Type Description wrapped method Source code in machine/plugins/decorators.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def process ( slack_event_type ): \"\"\"Process Slack events of a specific type This decorator will enable a Plugin method to process `Slack events`_ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events :param slack_event_type: type of event the method needs to process. Can be any event supported by the RTM API :return: wrapped method \"\"\" def process_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"process\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"process\" , {}) f . metadata [ \"plugin_actions\" ][ \"process\" ][ \"event_type\" ] = slack_event_type return f return process_decorator listen_to ( regex , flags = re . IGNORECASE ) Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex regex pattern to listen for required flags regex flags to apply when matching re.IGNORECASE Returns: Type Description wrapped method Source code in machine/plugins/decorators.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def listen_to ( regex , flags = re . IGNORECASE ): \"\"\"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def listen_to_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"listen_to\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"listen_to\" , {}) f . metadata [ \"plugin_actions\" ][ \"listen_to\" ][ \"regex\" ] = f . metadata [ \"plugin_actions\" ][ \"listen_to\" ] . get ( \"regex\" , []) f . metadata [ \"plugin_actions\" ][ \"listen_to\" ][ \"regex\" ] . append ( re . compile ( regex , flags )) return f return listen_to_decorator respond_to ( regex , flags = re . IGNORECASE ) Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex regex pattern to listen for required flags regex flags to apply when matching re.IGNORECASE Returns: Type Description wrapped method Source code in machine/plugins/decorators.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def respond_to ( regex , flags = re . IGNORECASE ): \"\"\"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def respond_to_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"respond_to\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"respond_to\" , {}) f . metadata [ \"plugin_actions\" ][ \"respond_to\" ][ \"regex\" ] = f . metadata [ \"plugin_actions\" ][ \"respond_to\" ] . get ( \"regex\" , [] ) f . metadata [ \"plugin_actions\" ][ \"respond_to\" ][ \"regex\" ] . append ( re . compile ( regex , flags )) return f return respond_to_decorator schedule ( year = None , month = None , day = None , week = None , day_of_week = None , hour = None , minute = None , second = None , start_date = None , end_date = None , timezone = None ) Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class: CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger> Parameters: Name Type Description Default year int|str 4-digit year None month int|str month (1-12) None day int|str day of the (1-31) None week int|str ISO week (1-53) None day_of_week int|str number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) None hour int|str hour (0-23) None minute int|str minute (0-59) None second int|str second (0-59) None start_date datetime|str earliest possible date/time to trigger on (inclusive) None end_date datetime|str latest possible date/time to trigger on (inclusive) None timezone datetime.tzinfo|str time zone to use for the date/time calculations (defaults to scheduler timezone) None Source code in machine/plugins/decorators.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def schedule ( year = None , month = None , day = None , week = None , day_of_week = None , hour = None , minute = None , second = None , start_date = None , end_date = None , timezone = None , ): \"\"\"Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class:`CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger>` :param int|str year: 4-digit year :param int|str month: month (1-12) :param int|str day: day of the (1-31) :param int|str week: ISO week (1-53) :param int|str day_of_week: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) :param int|str hour: hour (0-23) :param int|str minute: minute (0-59) :param int|str second: second (0-59) :param datetime|str start_date: earliest possible date/time to trigger on (inclusive) :param datetime|str end_date: latest possible date/time to trigger on (inclusive) :param datetime.tzinfo|str timezone: time zone to use for the date/time calculations (defaults to scheduler timezone) \"\"\" kwargs = locals () def schedule_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"schedule\" ] = kwargs return f return schedule_decorator on ( event ) Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. Parameters: Name Type Description Default event name of the event to listen for. Event names are global required Source code in machine/plugins/decorators.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def on ( event ): \"\"\"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. :param event: name of the event to listen for. Event names are global \"\"\" def on_decorator ( f ): e = signal ( event ) e . connect ( f ) return f return on_decorator required_settings ( settings ) Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. Parameters: Name Type Description Default settings settings that are required (can be list of strings, or single string) required Source code in machine/plugins/decorators.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def required_settings ( settings ): \"\"\"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. :param settings: settings that are required (can be list of strings, or single string) \"\"\" def required_settings_decorator ( f_or_cls ): f_or_cls . metadata = getattr ( f_or_cls , \"metadata\" , {}) f_or_cls . metadata [ \"required_settings\" ] = f_or_cls . metadata . get ( \"required_settings\" , []) if isinstance ( settings , list ): f_or_cls . metadata [ \"required_settings\" ] . extend ( settings ) elif isinstance ( settings , str ): f_or_cls . metadata [ \"required_settings\" ] . append ( settings ) return f_or_cls return required_settings_decorator route ( path , ** kwargs ) Define a http route that should trigger the function The parameters to this decorator will be passed to the route function of Bottle Parameters: Name Type Description Default path path to match required kwargs additional keyword arguments to be passed to Bottle required Source code in machine/plugins/decorators.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def route ( path , ** kwargs ): \"\"\"Define a http route that should trigger the function The parameters to this decorator will be passed to the ``route`` function of Bottle :param path: path to match :param kwargs: additional keyword arguments to be passed to Bottle \"\"\" def route_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"route\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"route\" , []) kwargs [ \"path\" ] = path f . metadata [ \"plugin_actions\" ][ \"route\" ] . append ( kwargs ) return f return route_decorator require_any_role ( required_roles = None ) Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. Parameters: Name Type Description Default required_roles list of roles required to use the plugin method None Source code in machine/plugins/decorators.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def require_any_role ( required_roles = None ): \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" required_roles = required_roles if required_roles else [] def middle ( func ): def wrapper ( self , msg , ** kwargs ): if matching_roles_by_user_id ( self , msg . sender . id , required_roles ): return func ( self , msg , ** kwargs ) else : msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) role_string = \", \" . join ([ f \"` { role } `\" for role in required_roles ]) notify_admins ( self , \"Attempt to execute unauthorized command\" , f \"User { msg . at_sender } tried to execute the following command:\" f \"``` { msg . text } ``` but lacks _one_ of these roles: { role_string } \" , ) # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ wrapper . metadata = getattr ( func , \"metadata\" , {}) return wrapper return middle require_all_roles ( required_roles = None ) Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. Parameters: Name Type Description Default required_roles list of roles required to use the plugin method None Source code in machine/plugins/decorators.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def require_all_roles ( required_roles = None ): \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" required_roles = required_roles if required_roles else [] def middle ( func ): def wrapper ( self , msg , ** kwargs ): if matching_roles_by_user_id ( self , msg . sender . id , required_roles ) == len ( required_roles ): return func ( self , msg , ** kwargs ) else : msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) role_string = \", \" . join ([ f \"` { role } `\" for role in required_roles ]) notify_admins ( self , \"Attempt to execute unauthorized command\" , f \"User { msg . at_sender } tried to execute the following command:\" f \"``` { msg . text } ``` but lacks _all_ of these roles: { role_string } \" , ) return # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ wrapper . metadata = getattr ( func , \"metadata\" , {}) return wrapper return middle Models These classes represent base objects from the Slack API machine.models.user.User dataclass User model that represents a user object from the Slack API Source code in machine/models/user.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass ( frozen = True ) class User : \"\"\" User model that represents a user object from the Slack API \"\"\" id : str team_id : Optional [ str ] name : str deleted : Optional [ bool ] profile : Profile is_bot : bool updated : int is_app_user : bool color : Optional [ str ] = None real_name : Optional [ str ] = None tz : Optional [ str ] = None tz_label : Optional [ str ] = None tz_offset : Optional [ int ] = None is_admin : Optional [ bool ] = None is_owner : Optional [ bool ] = None is_primary_owner : Optional [ bool ] = None is_restricted : Optional [ bool ] = None is_ultra_restricted : Optional [ bool ] = None is_stranger : Optional [ bool ] = None has_2fa : Optional [ bool ] = None locale : Optional [ str ] = None @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"User\" : return from_dict ( data_class = User , data = user_reponse ) # pragma: no cover def fmt_mention ( self ) -> str : return f \"<@ { self . id } >\" machine.models.channel.Channel dataclass Channel model that represents a channel object from the Slack API Source code in machine/models/channel.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @dataclass ( frozen = True ) class Channel : \"\"\" Channel model that represents a channel object from the Slack API \"\"\" id : str name : Optional [ str ] is_channel : Optional [ bool ] created : int creator : Optional [ str ] is_archived : bool is_general : Optional [ bool ] name_normalized : Optional [ str ] is_shared : Optional [ bool ] is_org_shared : bool is_member : Optional [ bool ] is_private : Optional [ bool ] is_mpim : Optional [ bool ] is_channel : Optional [ bool ] is_group : Optional [ bool ] is_im : Optional [ bool ] user : Optional [ str ] topic : Optional [ PurposeTopic ] purpose : Optional [ PurposeTopic ] previous_names : Optional [ List [ str ]] _members : List [ str ] = field ( default_factory = list ) @property def identifier ( self ): if self . name : return self . name else : return self . id @property def members ( self ) -> Optional [ List [ str ]]: \"\"\"Get the member IDs for the given users.\"\"\" if not self . _members : self . _load_members () return self . _members def _load_members ( self ): \"\"\"Load a fresh set of members.\"\"\" from machine.clients.singletons.slack import LowLevelSlackClient , call_paginated_endpoint web_client = LowLevelSlackClient . get_instance () . web_client all_members = call_paginated_endpoint ( web_client . conversations_members , \"members\" , channel = self . id ) self . _members . clear () for member in all_members : self . _members . append ( member ) @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"Channel\" : return from_dict ( data_class = Channel , data = user_reponse ) members () -> Optional [ List [ str ]] property Get the member IDs for the given users. Source code in machine/models/channel.py 49 50 51 52 53 54 @property def members ( self ) -> Optional [ List [ str ]]: \"\"\"Get the member IDs for the given users.\"\"\" if not self . _members : self . _load_members () return self . _members Storage Storage is exposed to plugins through the self.storage field. The following class implements the interface plugins can use to interact with the storage backend. machine.storage.PluginStorage Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using self.storage . Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by dill _, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill Source code in machine/storage/__init__.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class PluginStorage : \"\"\"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using ``self.storage``. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by `dill`_, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill \"\"\" def __init__ ( self , fq_plugin_name ): self . _fq_plugin_name = fq_plugin_name def _gen_unique_key ( self , key ): return f \" { self . _fq_plugin_name } : { key } \" def _namespace_key ( self , key , shared ): return key if shared else self . _gen_unique_key ( key ) def set ( self , key , value , expires = None , shared = False ): \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) Storage . get_instance () . set ( namespaced_key , pickled_value , expires ) def get ( self , key , shared = False ): \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = Storage . get_instance () . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None def has ( self , key , shared = False ): \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return Storage . get_instance () . has ( namespaced_key ) def delete ( self , key , shared = False ): \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) Storage . get_instance () . delete ( namespaced_key ) def get_storage_size ( self ): \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return Storage . get_instance () . size () def get_storage_size_human ( self ): \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" return sizeof_fmt ( self . get_storage_size ()) def __contains__ ( self , key ): return self . has ( key , False ) set ( key , value , expires = None , shared = False ) Store or update a value by key Parameters: Name Type Description Default key the key under which to store the data required value the data to store required expires optional number of seconds after which the data is expired None shared True/False wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. False Source code in machine/storage/__init__.py 27 28 29 30 31 32 33 34 35 36 37 38 def set ( self , key , value , expires = None , shared = False ): \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) Storage . get_instance () . set ( namespaced_key , pickled_value , expires ) get ( key , shared = False ) Retrieve data by key Parameters: Name Type Description Default key key for the data to retrieve required shared True/False wether to retrieve data from the shared (global) namespace. False Returns: Type Description the data, or None if the key cannot be found/has expired Source code in machine/storage/__init__.py 40 41 42 43 44 45 46 47 48 49 50 51 52 def get ( self , key , shared = False ): \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = Storage . get_instance () . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None has ( key , shared = False ) Check if the key exists in storage Note: this class implements __contains__ so instead of calling self.storage.has(...) , you can also use: key in self.storage . This will check the namespaced version of the key, so it's the same as: self.storage.has('key', shared=False) Parameters: Name Type Description Default key key to check required shared True/False wether to check in the shared (global) namespace False Returns: Type Description True/False wether the key exists. Can only return True if the key has not expired. Source code in machine/storage/__init__.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def has ( self , key , shared = False ): \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return Storage . get_instance () . has ( namespaced_key ) delete ( key , shared = False ) Remove a key and its data from storage Parameters: Name Type Description Default key key to remove required shared True/False wether the key to remove should be in the shared (global) namespace False Source code in machine/storage/__init__.py 70 71 72 73 74 75 76 77 78 def delete ( self , key , shared = False ): \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) Storage . get_instance () . delete ( namespaced_key ) get_storage_size () Calculate the total size of the storage Returns: Type Description the total size of the storage in bytes (integer) Source code in machine/storage/__init__.py 80 81 82 83 84 85 def get_storage_size ( self ): \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return Storage . get_instance () . size () get_storage_size_human () Calculate the total size of the storage in human readable format Returns: Type Description the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. Source code in machine/storage/__init__.py 87 88 89 90 91 92 93 def get_storage_size_human ( self ): \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" return sizeof_fmt ( self . get_storage_size ()) New Storage Backends can be implemented by extending the following class: machine.storage.backends.base.MachineBaseStorage Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these: Serialization/Deserialization of data Namespacing of keys (so data stored by different plugins doesn't clash) Source code in machine/storage/backends/base.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class MachineBaseStorage : \"\"\"Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends **do not** have to deal with the following, because Slack Machine takes care of these: - Serialization/Deserialization of data - Namespacing of keys (so data stored by different plugins doesn't clash) \"\"\" def __init__ ( self , settings ): self . settings = settings def get ( self , key ): \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" raise NotImplementedError def set ( self , key , value , expires = None ): \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" raise NotImplementedError def delete ( self , key ): \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" raise NotImplementedError def has ( self , key ): \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" raise NotImplementedError def size ( self ): \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" raise NotImplementedError get ( key ) Retrieve data by key Parameters: Name Type Description Default key key for which to retrieve data required Returns: Type Description the raw data for the provided key, as (byte)string. Should return None when the key is unknown or the data has expired. Source code in machine/storage/backends/base.py 15 16 17 18 19 20 21 22 def get ( self , key ): \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" raise NotImplementedError set ( key , value , expires = None ) Store data by key Parameters: Name Type Description Default key the key under which to store the data required value data as (byte)string required expires optional expiration time in seconds, after which the data should not be returned any more. None Source code in machine/storage/backends/base.py 24 25 26 27 28 29 30 31 32 def set ( self , key , value , expires = None ): \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" raise NotImplementedError delete ( key ) Delete data by key Parameters: Name Type Description Default key key for which to delete the data required Source code in machine/storage/backends/base.py 34 35 36 37 38 39 def delete ( self , key ): \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" raise NotImplementedError has ( key ) Check if the key exists Parameters: Name Type Description Default key key to check required Returns: Type Description True/False wether the key exists Source code in machine/storage/backends/base.py 41 42 43 44 45 46 47 def has ( self , key ): \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" raise NotImplementedError size () Calculate the total size of the storage Returns: Type Description total size of storage in bytes (integer) Source code in machine/storage/backends/base.py 49 50 51 52 53 54 def size ( self ): \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" raise NotImplementedError","title":"API Documentation"},{"location":"api/#api-documentation","text":"This is the API documentation of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented.","title":"API Documentation"},{"location":"api/#plugin-classes","text":"The following 2 classes form the basis for Plugin development.","title":"Plugin classes"},{"location":"api/#machine.plugins.base.MachineBasePlugin","text":"Base class for all Slack Machine plugins The purpose of this class is two-fold: It acts as a marker-class so Slack Machine can recognize plugins as such It provides a lot of common functionality and convenience methods for plugins to interact with channels and users Attributes: Name Type Description settings Slack Machine settings object that contains all settings that were defined through local_settings.py Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. Source code in machine/plugins/base.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 class MachineBasePlugin : \"\"\"Base class for all Slack Machine plugins The purpose of this class is two-fold: 1. It acts as a marker-class so Slack Machine can recognize plugins as such 2. It provides a lot of common functionality and convenience methods for plugins to interact with channels and users :var settings: Slack Machine settings object that contains all settings that were defined through ``local_settings.py`` Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. \"\"\" def __init__ ( self , client : SlackClient , settings : CaseInsensitiveDict , storage : PluginStorage ): self . _client = client self . storage = storage self . settings = settings self . _fq_name = f \" { self . __module__ } . { self . __class__ . __name__ } \" def init ( self ): \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass @property def users ( self ) -> Dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users @property def channels ( self ) -> Dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels def find_channel_by_name ( self , channel_name : str ) -> Optional [ Channel ]: \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c @property def bot_info ( self ) -> Dict [ str , str ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () def say ( self , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def say_scheduled ( self , when : datetime , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional :py:class:`~machine.models.user.User` object or id of user if the message needs to visible to that specific user only :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def react ( self , channel : Union [ Channel , str ], ts : str , emoji : str ): \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( channel , ts , emoji ) def send_dm ( self , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) def send_dm_scheduled ( self , when : datetime , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs ) def emit ( self , event : str , ** kwargs ): \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" e = signal ( event ) e . send ( self , ** kwargs )","title":"MachineBasePlugin"},{"location":"api/#machine.plugins.base.MachineBasePlugin.init","text":"Initialize plugin This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via self.settings , and access storage through self.storage , but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. Returns: Type Description None Source code in machine/plugins/base.py 36 37 38 39 40 41 42 43 44 45 46 def init ( self ): \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass","title":"init()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.users","text":"Dictionary of all users in the Slack workspace Returns: Type Description Dict [ str , User ] a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class: ~machine.models.user.User object Source code in machine/plugins/base.py 48 49 50 51 52 53 54 55 @property def users ( self ) -> Dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users","title":"users()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.channels","text":"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. Returns: Type Description Dict [ str , Channel ] a list of all channels in the Slack workspace, where each channel is a :py:class: ~machine.models.channel.Channel object Source code in machine/plugins/base.py 57 58 59 60 61 62 63 64 65 66 67 68 @property def channels ( self ) -> Dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels","title":"channels()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.find_channel_by_name","text":"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. Parameters: Name Type Description Default channel_name str The name of the channel to retrieve. required Returns: Type Description Optional [ Channel ] The channel if found, None otherwise. Source code in machine/plugins/base.py 70 71 72 73 74 75 76 77 78 79 80 def find_channel_by_name ( self , channel_name : str ) -> Optional [ Channel ]: \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c","title":"find_channel_by_name()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.bot_info","text":"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine Returns: Type Description Dict [ str , str ] Bot user Source code in machine/plugins/base.py 82 83 84 85 86 87 88 89 90 91 @property def bot_info ( self ) -> Dict [ str , str ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info","title":"bot_info()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.at","text":"Create a mention of the provided user Create a mention of the provided user in the form of <@[user_id]> . This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth: ~machine.plugins.base.MachineBasePlugin.say Parameters: Name Type Description Default user User user your want to mention required Returns: Type Description str user mention Source code in machine/plugins/base.py 93 94 95 96 97 98 99 100 101 102 103 104 def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention ()","title":"at()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say","text":"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral_user takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default channel Union [ Channel , str ] :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral_user Union [ User , str , None] optional user name or id if the message needs to visible to a specific user only None Returns: Type Description Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral_user is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def say ( self , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say_scheduled","text":"Schedule a message to a channel This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required channel Union [ Channel , str ] :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral_user Union [ User , str , None] optional :py:class: ~machine.models.user.User object or id of user if the message needs to visible to that specific user only None Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def say_scheduled ( self , when : datetime , channel : Union [ Channel , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral_user : Union [ User , str , None ] = None , ** kwargs , ): \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional :py:class:`~machine.models.user.User` object or id of user if the message needs to visible to that specific user only :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say_scheduled()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.react","text":"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. Parameters: Name Type Description Default channel Union [ Channel , str ] :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required ts str timestamp of the message to react to required emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def react ( self , channel : Union [ Channel , str ], ts : str , emoji : str ): \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( channel , ts , emoji )","title":"react()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm","text":"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default user Union [ User , str ] :py:class: ~machine.models.user.User object or id of user to send DM to. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def send_dm ( self , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs )","title":"send_dm()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm_scheduled","text":"Schedule a Direct Message This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.send_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required user Union [ User , str ] :py:class: ~machine.models.user.User object or id of user to send DM to. required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def send_dm_scheduled ( self , when : datetime , user : Union [ User , str ], text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs )","title":"send_dm_scheduled()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.emit","text":"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. Parameters: Name Type Description Default event str name of the event required kwargs any data you want to emit with the event required Returns: Type Description None Source code in machine/plugins/base.py 271 272 273 274 275 276 277 278 279 280 281 282 def emit ( self , event : str , ** kwargs ): \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" e = signal ( event ) e . send ( self , ** kwargs )","title":"emit()"},{"location":"api/#machine.plugins.base.Message","text":"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The Message class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. Source code in machine/plugins/base.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 class Message : \"\"\"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The ``Message`` class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. \"\"\" def __init__ ( self , client : SlackClient , msg_event : Dict [ str , Any ], plugin_class_name : str ): self . _client = client self . _msg_event = msg_event self . _fq_plugin_name = plugin_class_name @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] @property def is_dm ( self ) -> bool : channel_id = self . _msg_event [ \"channel\" ] return not ( channel_id . startswith ( \"C\" ) or channel_id . startswith ( \"G\" )) @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () def say ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def say_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) def reply ( self , text , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) def reply_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread and not ephemeral : return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) def reply_dm ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs ) def react ( self , emoji : str ): \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) def _create_reply ( self , text ): if not self . is_dm : return f \" { self . at_sender } : { text } \" else : return text @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] @property def in_thread ( self ): \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event def __str__ ( self ): if self . channel . is_im : message = f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in DM\" else : message = \"Message ' {} ', sent by user @ {} in channel # {} \" . format ( self . text , self . sender . profile . real_name , self . channel . name ) return message def __repr__ ( self ): return \"Message(text= {} , sender= {} , channel= {} )\" . format ( repr ( self . text ), repr ( self . sender . profile . real_name ), repr ( self . channel . name ) )","title":"Message"},{"location":"api/#machine.plugins.base.Message.sender","text":"The sender of the message Returns: Type Description User the User the message was sent by Source code in machine/plugins/base.py 301 302 303 304 305 306 307 @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]]","title":"sender()"},{"location":"api/#machine.plugins.base.Message.channel","text":"The channel the message was sent to Returns: Type Description Channel the Channel the message was sent to Source code in machine/plugins/base.py 309 310 311 312 313 314 315 @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]]","title":"channel()"},{"location":"api/#machine.plugins.base.Message.text","text":"The body of the actual message Returns: Type Description str the body (text) of the actual message Source code in machine/plugins/base.py 322 323 324 325 326 327 328 @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ]","title":"text()"},{"location":"api/#machine.plugins.base.Message.at_sender","text":"The sender of the message formatted as mention Returns: Type Description str a string representation of the sender of the message, formatted as mention _, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users Source code in machine/plugins/base.py 330 331 332 333 334 335 336 337 338 339 @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention ()","title":"at_sender()"},{"location":"api/#machine.plugins.base.Message.say","text":"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def say ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say()"},{"location":"api/#machine.plugins.base.Message.say_scheduled","text":"Schedule a message This is the scheduled version of :py:meth: ~machine.plugins.base.Message.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None thread_ts Optional [ str ] optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def say_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , thread_ts : Optional [ str ] = None , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say_scheduled()"},{"location":"api/#machine.plugins.base.Message.reply","text":"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using blocks and/or attachments is possible. You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over in_thread Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def reply ( self , text , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs )","title":"reply()"},{"location":"api/#machine.plugins.base.Message.reply_scheduled","text":"Schedule a reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply . It behaves the same, but will send the reply at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def reply_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs , ): \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread and not ephemeral : return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs )","title":"reply_scheduled()"},{"location":"api/#machine.plugins.base.Message.reply_dm","text":"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 def reply_dm ( self , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs )","title":"reply_dm()"},{"location":"api/#machine.plugins.base.Message.reply_dm_scheduled","text":"Schedule a DM reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Union [ List [ Attachment ], List [ Dict [ str , Any ]], None] optional attachments (see attachments _) None blocks Union [ List [ Block ], List [ Dict [ str , Any ]], None] optional blocks (see blocks _) None Returns: Type Description None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Union [ List [ Attachment ], List [ Dict [ str , Any ]], None ] = None , blocks : Union [ List [ Block ], List [ Dict [ str , Any ]], None ] = None , ** kwargs , ): \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs )","title":"reply_dm_scheduled()"},{"location":"api/#machine.plugins.base.Message.react","text":"React to the original message Add a reaction to the original message Parameters: Name Type Description Default emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 570 571 572 573 574 575 576 577 578 579 580 def react ( self , emoji : str ): \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji )","title":"react()"},{"location":"api/#machine.plugins.base.Message.ts","text":"The timestamp of the message Returns: Type Description str the timestamp of the message Source code in machine/plugins/base.py 588 589 590 591 592 593 594 @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ]","title":"ts()"},{"location":"api/#machine.plugins.base.Message.in_thread","text":"Is message in a thread Returns: Type Description bool Source code in machine/plugins/base.py 596 597 598 599 600 601 602 @property def in_thread ( self ): \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event","title":"in_thread()"},{"location":"api/#decorators","text":"These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.)","title":"Decorators"},{"location":"api/#machine.plugins.decorators","text":"","title":"decorators"},{"location":"api/#machine.plugins.decorators.process","text":"Process Slack events of a specific type This decorator will enable a Plugin method to process Slack events _ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events Parameters: Name Type Description Default slack_event_type type of event the method needs to process. Can be any event supported by the RTM API required Returns: Type Description wrapped method Source code in machine/plugins/decorators.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def process ( slack_event_type ): \"\"\"Process Slack events of a specific type This decorator will enable a Plugin method to process `Slack events`_ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events :param slack_event_type: type of event the method needs to process. Can be any event supported by the RTM API :return: wrapped method \"\"\" def process_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"process\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"process\" , {}) f . metadata [ \"plugin_actions\" ][ \"process\" ][ \"event_type\" ] = slack_event_type return f return process_decorator","title":"process()"},{"location":"api/#machine.plugins.decorators.listen_to","text":"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex regex pattern to listen for required flags regex flags to apply when matching re.IGNORECASE Returns: Type Description wrapped method Source code in machine/plugins/decorators.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def listen_to ( regex , flags = re . IGNORECASE ): \"\"\"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def listen_to_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"listen_to\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"listen_to\" , {}) f . metadata [ \"plugin_actions\" ][ \"listen_to\" ][ \"regex\" ] = f . metadata [ \"plugin_actions\" ][ \"listen_to\" ] . get ( \"regex\" , []) f . metadata [ \"plugin_actions\" ][ \"listen_to\" ][ \"regex\" ] . append ( re . compile ( regex , flags )) return f return listen_to_decorator","title":"listen_to()"},{"location":"api/#machine.plugins.decorators.respond_to","text":"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex regex pattern to listen for required flags regex flags to apply when matching re.IGNORECASE Returns: Type Description wrapped method Source code in machine/plugins/decorators.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def respond_to ( regex , flags = re . IGNORECASE ): \"\"\"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def respond_to_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"respond_to\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"respond_to\" , {}) f . metadata [ \"plugin_actions\" ][ \"respond_to\" ][ \"regex\" ] = f . metadata [ \"plugin_actions\" ][ \"respond_to\" ] . get ( \"regex\" , [] ) f . metadata [ \"plugin_actions\" ][ \"respond_to\" ][ \"regex\" ] . append ( re . compile ( regex , flags )) return f return respond_to_decorator","title":"respond_to()"},{"location":"api/#machine.plugins.decorators.schedule","text":"Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class: CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger> Parameters: Name Type Description Default year int|str 4-digit year None month int|str month (1-12) None day int|str day of the (1-31) None week int|str ISO week (1-53) None day_of_week int|str number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) None hour int|str hour (0-23) None minute int|str minute (0-59) None second int|str second (0-59) None start_date datetime|str earliest possible date/time to trigger on (inclusive) None end_date datetime|str latest possible date/time to trigger on (inclusive) None timezone datetime.tzinfo|str time zone to use for the date/time calculations (defaults to scheduler timezone) None Source code in machine/plugins/decorators.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def schedule ( year = None , month = None , day = None , week = None , day_of_week = None , hour = None , minute = None , second = None , start_date = None , end_date = None , timezone = None , ): \"\"\"Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class:`CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger>` :param int|str year: 4-digit year :param int|str month: month (1-12) :param int|str day: day of the (1-31) :param int|str week: ISO week (1-53) :param int|str day_of_week: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) :param int|str hour: hour (0-23) :param int|str minute: minute (0-59) :param int|str second: second (0-59) :param datetime|str start_date: earliest possible date/time to trigger on (inclusive) :param datetime|str end_date: latest possible date/time to trigger on (inclusive) :param datetime.tzinfo|str timezone: time zone to use for the date/time calculations (defaults to scheduler timezone) \"\"\" kwargs = locals () def schedule_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"schedule\" ] = kwargs return f return schedule_decorator","title":"schedule()"},{"location":"api/#machine.plugins.decorators.on","text":"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. Parameters: Name Type Description Default event name of the event to listen for. Event names are global required Source code in machine/plugins/decorators.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def on ( event ): \"\"\"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. :param event: name of the event to listen for. Event names are global \"\"\" def on_decorator ( f ): e = signal ( event ) e . connect ( f ) return f return on_decorator","title":"on()"},{"location":"api/#machine.plugins.decorators.required_settings","text":"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. Parameters: Name Type Description Default settings settings that are required (can be list of strings, or single string) required Source code in machine/plugins/decorators.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def required_settings ( settings ): \"\"\"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. :param settings: settings that are required (can be list of strings, or single string) \"\"\" def required_settings_decorator ( f_or_cls ): f_or_cls . metadata = getattr ( f_or_cls , \"metadata\" , {}) f_or_cls . metadata [ \"required_settings\" ] = f_or_cls . metadata . get ( \"required_settings\" , []) if isinstance ( settings , list ): f_or_cls . metadata [ \"required_settings\" ] . extend ( settings ) elif isinstance ( settings , str ): f_or_cls . metadata [ \"required_settings\" ] . append ( settings ) return f_or_cls return required_settings_decorator","title":"required_settings()"},{"location":"api/#machine.plugins.decorators.route","text":"Define a http route that should trigger the function The parameters to this decorator will be passed to the route function of Bottle Parameters: Name Type Description Default path path to match required kwargs additional keyword arguments to be passed to Bottle required Source code in machine/plugins/decorators.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def route ( path , ** kwargs ): \"\"\"Define a http route that should trigger the function The parameters to this decorator will be passed to the ``route`` function of Bottle :param path: path to match :param kwargs: additional keyword arguments to be passed to Bottle \"\"\" def route_decorator ( f ): f . metadata = getattr ( f , \"metadata\" , {}) f . metadata [ \"plugin_actions\" ] = f . metadata . get ( \"plugin_actions\" , {}) f . metadata [ \"plugin_actions\" ][ \"route\" ] = f . metadata [ \"plugin_actions\" ] . get ( \"route\" , []) kwargs [ \"path\" ] = path f . metadata [ \"plugin_actions\" ][ \"route\" ] . append ( kwargs ) return f return route_decorator","title":"route()"},{"location":"api/#machine.plugins.decorators.require_any_role","text":"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. Parameters: Name Type Description Default required_roles list of roles required to use the plugin method None Source code in machine/plugins/decorators.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def require_any_role ( required_roles = None ): \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" required_roles = required_roles if required_roles else [] def middle ( func ): def wrapper ( self , msg , ** kwargs ): if matching_roles_by_user_id ( self , msg . sender . id , required_roles ): return func ( self , msg , ** kwargs ) else : msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) role_string = \", \" . join ([ f \"` { role } `\" for role in required_roles ]) notify_admins ( self , \"Attempt to execute unauthorized command\" , f \"User { msg . at_sender } tried to execute the following command:\" f \"``` { msg . text } ``` but lacks _one_ of these roles: { role_string } \" , ) # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ wrapper . metadata = getattr ( func , \"metadata\" , {}) return wrapper return middle","title":"require_any_role()"},{"location":"api/#machine.plugins.decorators.require_all_roles","text":"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. Parameters: Name Type Description Default required_roles list of roles required to use the plugin method None Source code in machine/plugins/decorators.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def require_all_roles ( required_roles = None ): \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" required_roles = required_roles if required_roles else [] def middle ( func ): def wrapper ( self , msg , ** kwargs ): if matching_roles_by_user_id ( self , msg . sender . id , required_roles ) == len ( required_roles ): return func ( self , msg , ** kwargs ) else : msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) role_string = \", \" . join ([ f \"` { role } `\" for role in required_roles ]) notify_admins ( self , \"Attempt to execute unauthorized command\" , f \"User { msg . at_sender } tried to execute the following command:\" f \"``` { msg . text } ``` but lacks _all_ of these roles: { role_string } \" , ) return # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ wrapper . metadata = getattr ( func , \"metadata\" , {}) return wrapper return middle","title":"require_all_roles()"},{"location":"api/#models","text":"These classes represent base objects from the Slack API","title":"Models"},{"location":"api/#machine.models.user.User","text":"User model that represents a user object from the Slack API Source code in machine/models/user.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass ( frozen = True ) class User : \"\"\" User model that represents a user object from the Slack API \"\"\" id : str team_id : Optional [ str ] name : str deleted : Optional [ bool ] profile : Profile is_bot : bool updated : int is_app_user : bool color : Optional [ str ] = None real_name : Optional [ str ] = None tz : Optional [ str ] = None tz_label : Optional [ str ] = None tz_offset : Optional [ int ] = None is_admin : Optional [ bool ] = None is_owner : Optional [ bool ] = None is_primary_owner : Optional [ bool ] = None is_restricted : Optional [ bool ] = None is_ultra_restricted : Optional [ bool ] = None is_stranger : Optional [ bool ] = None has_2fa : Optional [ bool ] = None locale : Optional [ str ] = None @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"User\" : return from_dict ( data_class = User , data = user_reponse ) # pragma: no cover def fmt_mention ( self ) -> str : return f \"<@ { self . id } >\"","title":"User"},{"location":"api/#machine.models.channel.Channel","text":"Channel model that represents a channel object from the Slack API Source code in machine/models/channel.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @dataclass ( frozen = True ) class Channel : \"\"\" Channel model that represents a channel object from the Slack API \"\"\" id : str name : Optional [ str ] is_channel : Optional [ bool ] created : int creator : Optional [ str ] is_archived : bool is_general : Optional [ bool ] name_normalized : Optional [ str ] is_shared : Optional [ bool ] is_org_shared : bool is_member : Optional [ bool ] is_private : Optional [ bool ] is_mpim : Optional [ bool ] is_channel : Optional [ bool ] is_group : Optional [ bool ] is_im : Optional [ bool ] user : Optional [ str ] topic : Optional [ PurposeTopic ] purpose : Optional [ PurposeTopic ] previous_names : Optional [ List [ str ]] _members : List [ str ] = field ( default_factory = list ) @property def identifier ( self ): if self . name : return self . name else : return self . id @property def members ( self ) -> Optional [ List [ str ]]: \"\"\"Get the member IDs for the given users.\"\"\" if not self . _members : self . _load_members () return self . _members def _load_members ( self ): \"\"\"Load a fresh set of members.\"\"\" from machine.clients.singletons.slack import LowLevelSlackClient , call_paginated_endpoint web_client = LowLevelSlackClient . get_instance () . web_client all_members = call_paginated_endpoint ( web_client . conversations_members , \"members\" , channel = self . id ) self . _members . clear () for member in all_members : self . _members . append ( member ) @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"Channel\" : return from_dict ( data_class = Channel , data = user_reponse )","title":"Channel"},{"location":"api/#machine.models.channel.Channel.members","text":"Get the member IDs for the given users. Source code in machine/models/channel.py 49 50 51 52 53 54 @property def members ( self ) -> Optional [ List [ str ]]: \"\"\"Get the member IDs for the given users.\"\"\" if not self . _members : self . _load_members () return self . _members","title":"members()"},{"location":"api/#storage","text":"Storage is exposed to plugins through the self.storage field. The following class implements the interface plugins can use to interact with the storage backend.","title":"Storage"},{"location":"api/#machine.storage.PluginStorage","text":"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using self.storage . Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by dill _, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill Source code in machine/storage/__init__.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class PluginStorage : \"\"\"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using ``self.storage``. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by `dill`_, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill \"\"\" def __init__ ( self , fq_plugin_name ): self . _fq_plugin_name = fq_plugin_name def _gen_unique_key ( self , key ): return f \" { self . _fq_plugin_name } : { key } \" def _namespace_key ( self , key , shared ): return key if shared else self . _gen_unique_key ( key ) def set ( self , key , value , expires = None , shared = False ): \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) Storage . get_instance () . set ( namespaced_key , pickled_value , expires ) def get ( self , key , shared = False ): \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = Storage . get_instance () . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None def has ( self , key , shared = False ): \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return Storage . get_instance () . has ( namespaced_key ) def delete ( self , key , shared = False ): \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) Storage . get_instance () . delete ( namespaced_key ) def get_storage_size ( self ): \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return Storage . get_instance () . size () def get_storage_size_human ( self ): \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" return sizeof_fmt ( self . get_storage_size ()) def __contains__ ( self , key ): return self . has ( key , False )","title":"PluginStorage"},{"location":"api/#machine.storage.PluginStorage.set","text":"Store or update a value by key Parameters: Name Type Description Default key the key under which to store the data required value the data to store required expires optional number of seconds after which the data is expired None shared True/False wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. False Source code in machine/storage/__init__.py 27 28 29 30 31 32 33 34 35 36 37 38 def set ( self , key , value , expires = None , shared = False ): \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) Storage . get_instance () . set ( namespaced_key , pickled_value , expires )","title":"set()"},{"location":"api/#machine.storage.PluginStorage.get","text":"Retrieve data by key Parameters: Name Type Description Default key key for the data to retrieve required shared True/False wether to retrieve data from the shared (global) namespace. False Returns: Type Description the data, or None if the key cannot be found/has expired Source code in machine/storage/__init__.py 40 41 42 43 44 45 46 47 48 49 50 51 52 def get ( self , key , shared = False ): \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = Storage . get_instance () . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None","title":"get()"},{"location":"api/#machine.storage.PluginStorage.has","text":"Check if the key exists in storage Note: this class implements __contains__ so instead of calling self.storage.has(...) , you can also use: key in self.storage . This will check the namespaced version of the key, so it's the same as: self.storage.has('key', shared=False) Parameters: Name Type Description Default key key to check required shared True/False wether to check in the shared (global) namespace False Returns: Type Description True/False wether the key exists. Can only return True if the key has not expired. Source code in machine/storage/__init__.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def has ( self , key , shared = False ): \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return Storage . get_instance () . has ( namespaced_key )","title":"has()"},{"location":"api/#machine.storage.PluginStorage.delete","text":"Remove a key and its data from storage Parameters: Name Type Description Default key key to remove required shared True/False wether the key to remove should be in the shared (global) namespace False Source code in machine/storage/__init__.py 70 71 72 73 74 75 76 77 78 def delete ( self , key , shared = False ): \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) Storage . get_instance () . delete ( namespaced_key )","title":"delete()"},{"location":"api/#machine.storage.PluginStorage.get_storage_size","text":"Calculate the total size of the storage Returns: Type Description the total size of the storage in bytes (integer) Source code in machine/storage/__init__.py 80 81 82 83 84 85 def get_storage_size ( self ): \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return Storage . get_instance () . size ()","title":"get_storage_size()"},{"location":"api/#machine.storage.PluginStorage.get_storage_size_human","text":"Calculate the total size of the storage in human readable format Returns: Type Description the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. Source code in machine/storage/__init__.py 87 88 89 90 91 92 93 def get_storage_size_human ( self ): \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" return sizeof_fmt ( self . get_storage_size ()) New Storage Backends can be implemented by extending the following class:","title":"get_storage_size_human()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage","text":"Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these: Serialization/Deserialization of data Namespacing of keys (so data stored by different plugins doesn't clash) Source code in machine/storage/backends/base.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class MachineBaseStorage : \"\"\"Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends **do not** have to deal with the following, because Slack Machine takes care of these: - Serialization/Deserialization of data - Namespacing of keys (so data stored by different plugins doesn't clash) \"\"\" def __init__ ( self , settings ): self . settings = settings def get ( self , key ): \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" raise NotImplementedError def set ( self , key , value , expires = None ): \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" raise NotImplementedError def delete ( self , key ): \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" raise NotImplementedError def has ( self , key ): \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" raise NotImplementedError def size ( self ): \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" raise NotImplementedError","title":"MachineBaseStorage"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.get","text":"Retrieve data by key Parameters: Name Type Description Default key key for which to retrieve data required Returns: Type Description the raw data for the provided key, as (byte)string. Should return None when the key is unknown or the data has expired. Source code in machine/storage/backends/base.py 15 16 17 18 19 20 21 22 def get ( self , key ): \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" raise NotImplementedError","title":"get()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.set","text":"Store data by key Parameters: Name Type Description Default key the key under which to store the data required value data as (byte)string required expires optional expiration time in seconds, after which the data should not be returned any more. None Source code in machine/storage/backends/base.py 24 25 26 27 28 29 30 31 32 def set ( self , key , value , expires = None ): \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" raise NotImplementedError","title":"set()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.delete","text":"Delete data by key Parameters: Name Type Description Default key key for which to delete the data required Source code in machine/storage/backends/base.py 34 35 36 37 38 39 def delete ( self , key ): \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" raise NotImplementedError","title":"delete()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.has","text":"Check if the key exists Parameters: Name Type Description Default key key to check required Returns: Type Description True/False wether the key exists Source code in machine/storage/backends/base.py 41 42 43 44 45 46 47 def has ( self , key ): \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" raise NotImplementedError","title":"has()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.size","text":"Calculate the total size of the storage Returns: Type Description total size of storage in bytes (integer) Source code in machine/storage/backends/base.py 49 50 51 52 53 54 def size ( self ): \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" raise NotImplementedError","title":"size()"},{"location":"api/api-async/","text":"API Documentation (Async) This is the API documentation of async versions of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented. Plugin classes The following 2 classes form the basis for Plugin development. machine.asyncio.plugins.base.MachineBasePlugin Base class for all Slack Machine plugins The purpose of this class is two-fold: It acts as a marker-class so Slack Machine can recognize plugins as such It provides a lot of common functionality and convenience methods for plugins to interact with channels and users Attributes: Name Type Description settings Slack Machine settings object that contains all settings that were defined through local_settings.py Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. Source code in machine/asyncio/plugins/base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 class MachineBasePlugin : \"\"\"Base class for all Slack Machine plugins The purpose of this class is two-fold: 1. It acts as a marker-class so Slack Machine can recognize plugins as such 2. It provides a lot of common functionality and convenience methods for plugins to interact with channels and users :var settings: Slack Machine settings object that contains all settings that were defined through ``local_settings.py`` Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. \"\"\" _client : SlackClient storage : PluginStorage settings : CaseInsensitiveDict _fq_name : str def __init__ ( self , client : SlackClient , settings : CaseInsensitiveDict , storage : PluginStorage ): self . _client = client self . storage = storage self . settings = settings self . _fq_name = f \" { self . __module__ } . { self . __class__ . __name__ } \" def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji ) async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs ) init () -> None Initialize plugin This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via self.settings , and access storage through self.storage , but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. Returns: Type Description None None Source code in machine/asyncio/plugins/base.py 43 44 45 46 47 48 49 50 51 52 53 def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass users () -> dict [ str , User ] property Dictionary of all users in the Slack workspace Returns: Type Description dict [ str , User ] a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class: ~machine.models.user.User object Source code in machine/asyncio/plugins/base.py 55 56 57 58 59 60 61 62 @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users channels () -> dict [ str , Channel ] property List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. Returns: Type Description dict [ str , Channel ] a list of all channels in the Slack workspace, where each channel is a :py:class: ~machine.models.channel.Channel object Source code in machine/asyncio/plugins/base.py 64 65 66 67 68 69 70 71 72 73 74 75 @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels find_channel_by_name ( channel_name : str ) -> Channel | None Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. Parameters: Name Type Description Default channel_name str The name of the channel to retrieve. required Returns: Type Description Channel | None The channel if found, None otherwise. Source code in machine/asyncio/plugins/base.py 77 78 79 80 81 82 83 84 85 86 87 88 def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None bot_info () -> dict [ str , Any ] property Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine Returns: Type Description dict [ str , Any ] Bot user Source code in machine/asyncio/plugins/base.py 90 91 92 93 94 95 96 97 98 99 @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info at ( user : User ) -> str Create a mention of the provided user Create a mention of the provided user in the form of <@[user_id]> . This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth: ~machine.plugins.base.MachineBasePlugin.say Parameters: Name Type Description Default user User user your want to mention required Returns: Type Description str user mention Source code in machine/asyncio/plugins/base.py 101 102 103 104 105 106 107 108 109 110 111 112 def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () say ( channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral_user takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral_user User | str | None optional user name or id if the message needs to visible to a specific user only None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral_user is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/asyncio/plugins/base.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) react ( channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse async React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required ts str timestamp of the message to react to required emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/asyncio/plugins/base.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji ) send_dm ( user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default user User | str :py:class: ~machine.models.user.User object or id of user to send DM to. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/asyncio/plugins/base.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) emit ( event : str , ** kwargs : Any ) -> None Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. Parameters: Name Type Description Default event str name of the event required kwargs any data you want to emit with the event required Returns: Type Description None None Source code in machine/asyncio/plugins/base.py 211 212 213 214 215 216 217 218 219 220 221 def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs ) machine.asyncio.plugins.base.Message A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The Message class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. Source code in machine/asyncio/plugins/base.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 class Message : \"\"\"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The ``Message`` class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. \"\"\" # TODO: create proper class for msg_event def __init__ ( self , client : SlackClient , msg_event : dict [ str , Any ], plugin_class_name : str ): self . _client = client self . _msg_event = msg_event self . _fq_plugin_name = plugin_class_name @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] @property def is_dm ( self ) -> bool : channel_id = self . _msg_event [ \"channel\" ] return not ( channel_id . startswith ( \"C\" ) or channel_id . startswith ( \"G\" )) @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) def _create_reply ( self , text : str | None ) -> str | None : if not self . is_dm and text is not None : return f \" { self . at_sender } : { text } \" else : return text @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event def __str__ ( self ) -> str : if self . channel . is_im : message = f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in DM\" else : message = \"Message ' {} ', sent by user @ {} in channel # {} \" . format ( self . text , self . sender . profile . real_name , self . channel . name ) return message def __repr__ ( self ) -> str : return \"Message(text= {} , sender= {} , channel= {} )\" . format ( repr ( self . text ), repr ( self . sender . profile . real_name ), repr ( self . channel . name ) ) sender () -> User property The sender of the message Returns: Type Description User the User the message was sent by Source code in machine/asyncio/plugins/base.py 241 242 243 244 245 246 247 @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] channel () -> Channel property The channel the message was sent to Returns: Type Description Channel the Channel the message was sent to Source code in machine/asyncio/plugins/base.py 249 250 251 252 253 254 255 @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] text () -> str property The body of the actual message Returns: Type Description str the body (text) of the actual message Source code in machine/asyncio/plugins/base.py 262 263 264 265 266 267 268 @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] at_sender () -> str property The sender of the message formatted as mention Returns: Type Description str a string representation of the sender of the message, formatted as mention _, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users Source code in machine/asyncio/plugins/base.py 270 271 272 273 274 275 276 277 278 279 @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () say ( text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any ) -> AsyncSlackResponse async Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/asyncio/plugins/base.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) reply ( text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any ) -> AsyncSlackResponse async Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using blocks and/or attachments is possible. You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over in_thread Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/asyncio/plugins/base.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) reply_dm ( text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/asyncio/plugins/base.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) react ( emoji : str ) -> AsyncSlackResponse async React to the original message Add a reaction to the original message Parameters: Name Type Description Default emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/asyncio/plugins/base.py 408 409 410 411 412 413 414 415 416 417 418 async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) ts () -> str property The timestamp of the message Returns: Type Description str the timestamp of the message Source code in machine/asyncio/plugins/base.py 426 427 428 429 430 431 432 @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] in_thread () -> bool property Is message in a thread Returns: Type Description bool bool Source code in machine/asyncio/plugins/base.py 434 435 436 437 438 439 440 @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event Decorators These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.) machine.asyncio.plugins.decorators process ( slack_event_type : str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Process Slack events of a specific type This decorator will enable a Plugin method to process Slack events _ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events Parameters: Name Type Description Default slack_event_type str type of event the method needs to process. Can be any event supported by the RTM API required Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/asyncio/plugins/decorators.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def process ( slack_event_type : str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Process Slack events of a specific type This decorator will enable a Plugin method to process `Slack events`_ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events :param slack_event_type: type of event the method needs to process. Can be any event supported by the RTM API :return: wrapped method \"\"\" def process_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . process . append ( slack_event_type ) return fn return process_decorator listen_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/asyncio/plugins/decorators.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def listen_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def listen_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . listen_to . append ( re . compile ( regex , flags )) return fn return listen_to_decorator respond_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/asyncio/plugins/decorators.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def respond_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def respond_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . respond_to . append ( re . compile ( regex , flags )) return fn return respond_to_decorator on ( event : str ) -> Callable [[ Callable [ P , R ]], Callable [ P , R ]] Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. Parameters: Name Type Description Default event str name of the event to listen for. Event names are global required Source code in machine/asyncio/plugins/decorators.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def on ( event : str ) -> Callable [[ Callable [ P , R ]], Callable [ P , R ]]: \"\"\"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. :param event: name of the event to listen for. Event names are global \"\"\" def on_decorator ( f : Callable [ P , R ]) -> Callable [ P , R ]: ee . add_listener ( event , f ) return f return on_decorator required_settings ( settings : list [ str ] | str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. Parameters: Name Type Description Default settings list [ str ] | str settings that are required (can be list of strings, or single string) required Source code in machine/asyncio/plugins/decorators.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def required_settings ( settings : list [ str ] | str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. :param settings: settings that are required (can be list of strings, or single string) \"\"\" def required_settings_decorator ( f_or_cls : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: casted_f_or_cls = cast ( DecoratedPluginFunc , f_or_cls ) casted_f_or_cls . metadata = getattr ( f_or_cls , \"metadata\" , Metadata ()) if isinstance ( settings , list ): casted_f_or_cls . metadata . required_settings . extend ( settings ) elif isinstance ( settings , str ): casted_f_or_cls . metadata . required_settings . append ( settings ) return casted_f_or_cls return required_settings_decorator require_any_role ( required_roles : list [ str ]) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]] Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/asyncio/plugins/decorators.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def require_any_role ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ): logger . debug ( f \"User { msg . sender } has one of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have any of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ANY , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle require_all_roles ( required_roles : list [ str ]) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]] Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/asyncio/plugins/decorators.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def require_all_roles ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ) == len ( required_roles ): logger . debug ( f \"User { msg . sender } has all of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have all of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ALL , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle Models These classes represent base objects from the Slack API machine.asyncio.models.user.User dataclass User model that represents a user object from the Slack API Source code in machine/asyncio/models/user.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass ( frozen = True ) class User : \"\"\" User model that represents a user object from the Slack API \"\"\" id : str team_id : Optional [ str ] name : str deleted : Optional [ bool ] profile : Profile is_bot : bool updated : int is_app_user : bool color : Optional [ str ] = None real_name : Optional [ str ] = None tz : Optional [ str ] = None tz_label : Optional [ str ] = None tz_offset : Optional [ int ] = None is_admin : Optional [ bool ] = None is_owner : Optional [ bool ] = None is_primary_owner : Optional [ bool ] = None is_restricted : Optional [ bool ] = None is_ultra_restricted : Optional [ bool ] = None is_stranger : Optional [ bool ] = None has_2fa : Optional [ bool ] = None locale : Optional [ str ] = None @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"User\" : return from_dict ( data_class = User , data = user_reponse ) # pragma: no cover def fmt_mention ( self ) -> str : return f \"<@ { self . id } >\" machine.asyncio.models.channel.Channel dataclass Channel model that represents a channel object from the Slack API Source code in machine/asyncio/models/channel.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @dataclass ( frozen = True ) class Channel : \"\"\" Channel model that represents a channel object from the Slack API \"\"\" id : str name : Optional [ str ] created : int creator : Optional [ str ] is_archived : bool is_general : Optional [ bool ] name_normalized : Optional [ str ] is_shared : Optional [ bool ] is_org_shared : bool is_member : Optional [ bool ] is_private : Optional [ bool ] is_mpim : Optional [ bool ] is_channel : Optional [ bool ] is_group : Optional [ bool ] is_im : Optional [ bool ] user : Optional [ str ] topic : Optional [ PurposeTopic ] purpose : Optional [ PurposeTopic ] previous_names : Optional [ List [ str ]] @property def identifier ( self ) -> str : if self . name : return self . name else : return self . id @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"Channel\" : return from_dict ( data_class = Channel , data = user_reponse ) Storage Storage is exposed to plugins through the self.storage field. The following class implements the interface plugins can use to interact with the storage backend. machine.asyncio.storage.PluginStorage Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using self.storage . Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by dill _, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill Source code in machine/asyncio/storage/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PluginStorage : \"\"\"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using ``self.storage``. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by `dill`_, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill \"\"\" def __init__ ( self , fq_plugin_name : str , storage_backend : MachineBaseStorage ): self . _fq_plugin_name = fq_plugin_name self . _storage = storage_backend def _gen_unique_key ( self , key : str ) -> str : return f \" { self . _fq_plugin_name } : { key } \" def _namespace_key ( self , key : str , shared : bool = False ) -> str : return key if shared else self . _gen_unique_key ( key ) async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires ) async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key ) async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key ) async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size () async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size ) set ( key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None async Store or update a value by key Parameters: Name Type Description Default key str the key under which to store the data required value Any the data to store required expires int | timedelta | None optional number of seconds after which the data is expired None shared bool True/False wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. False Source code in machine/asyncio/storage/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires ) get ( key : str , shared : bool = False ) -> Any | None async Retrieve data by key Parameters: Name Type Description Default key str key for the data to retrieve required shared bool True/False wether to retrieve data from the shared (global) namespace. False Returns: Type Description Any | None the data, or None if the key cannot be found/has expired Source code in machine/asyncio/storage/__init__.py 47 48 49 50 51 52 53 54 55 56 57 58 59 async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None has ( key : str , shared : bool = False ) -> bool async Check if the key exists in storage Note: this class implements __contains__ so instead of calling self.storage.has(...) , you can also use: key in self.storage . This will check the namespaced version of the key, so it's the same as: self.storage.has('key', shared=False) Parameters: Name Type Description Default key str key to check required shared bool True/False wether to check in the shared (global) namespace False Returns: Type Description bool True/False wether the key exists. Can only return True if the key has not expired. Source code in machine/asyncio/storage/__init__.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key ) delete ( key : str , shared : bool = False ) -> None async Remove a key and its data from storage Parameters: Name Type Description Default key str key to remove required shared bool True/False wether the key to remove should be in the shared (global) namespace False Source code in machine/asyncio/storage/__init__.py 77 78 79 80 81 82 83 84 85 async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key ) get_storage_size () -> int async Calculate the total size of the storage Returns: Type Description int the total size of the storage in bytes (integer) Source code in machine/asyncio/storage/__init__.py 87 88 89 90 91 92 async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size () get_storage_size_human () -> str async Calculate the total size of the storage in human readable format Returns: Type Description str the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. Source code in machine/asyncio/storage/__init__.py 94 95 96 97 98 99 100 101 async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size ) New Storage Backends can be implemented by extending the following class: machine.asyncio.storage.backends.base.MachineBaseStorage Bases: ABC Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these: Serialization/Deserialization of data Namespacing of keys (so data stored by different plugins doesn't clash) Source code in machine/asyncio/storage/backends/base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class MachineBaseStorage ( ABC ): \"\"\"Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends **do not** have to deal with the following, because Slack Machine takes care of these: - Serialization/Deserialization of data - Namespacing of keys (so data stored by different plugins doesn't clash) \"\"\" settings : dict [ str , Any ] def __init__ ( self , settings : dict [ str , Any ]): self . settings = settings @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ... @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ... @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ... @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ... @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ... @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ... get ( key : str ) -> bytes | None abstractmethod async Retrieve data by key Parameters: Name Type Description Default key str key for which to retrieve data required Returns: Type Description bytes | None the raw data for the provided key, as (byte)string. Should return None when the key is unknown or the data has expired. Source code in machine/asyncio/storage/backends/base.py 22 23 24 25 26 27 28 29 30 @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ... set ( key : str , value : bytes , expires : int | None = None ) -> None abstractmethod async Store data by key Parameters: Name Type Description Default key str the key under which to store the data required value bytes data as (byte)string required expires int | None optional expiration time in seconds, after which the data should not be returned any more. None Source code in machine/asyncio/storage/backends/base.py 32 33 34 35 36 37 38 39 40 41 @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ... delete ( key : str ) -> None abstractmethod async Delete data by key Parameters: Name Type Description Default key str key for which to delete the data required Source code in machine/asyncio/storage/backends/base.py 43 44 45 46 47 48 49 @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ... has ( key : str ) -> bool abstractmethod async Check if the key exists Parameters: Name Type Description Default key str key to check required Returns: Type Description bool True/False wether the key exists Source code in machine/asyncio/storage/backends/base.py 51 52 53 54 55 56 57 58 @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ... size () -> int abstractmethod async Calculate the total size of the storage Returns: Type Description int total size of storage in bytes (integer) Source code in machine/asyncio/storage/backends/base.py 60 61 62 63 64 65 66 @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ... close () -> None abstractmethod async Close the storage backend Source code in machine/asyncio/storage/backends/base.py 68 69 70 71 @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ...","title":"API Documentation (Async)"},{"location":"api/api-async/#api-documentation-async","text":"This is the API documentation of async versions of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented.","title":"API Documentation (Async)"},{"location":"api/api-async/#plugin-classes","text":"The following 2 classes form the basis for Plugin development.","title":"Plugin classes"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin","text":"Base class for all Slack Machine plugins The purpose of this class is two-fold: It acts as a marker-class so Slack Machine can recognize plugins as such It provides a lot of common functionality and convenience methods for plugins to interact with channels and users Attributes: Name Type Description settings Slack Machine settings object that contains all settings that were defined through local_settings.py Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. Source code in machine/asyncio/plugins/base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 class MachineBasePlugin : \"\"\"Base class for all Slack Machine plugins The purpose of this class is two-fold: 1. It acts as a marker-class so Slack Machine can recognize plugins as such 2. It provides a lot of common functionality and convenience methods for plugins to interact with channels and users :var settings: Slack Machine settings object that contains all settings that were defined through ``local_settings.py`` Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. \"\"\" _client : SlackClient storage : PluginStorage settings : CaseInsensitiveDict _fq_name : str def __init__ ( self , client : SlackClient , settings : CaseInsensitiveDict , storage : PluginStorage ): self . _client = client self . storage = storage self . settings = settings self . _fq_name = f \" { self . __module__ } . { self . __class__ . __name__ } \" def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji ) async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs )","title":"MachineBasePlugin"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.init","text":"Initialize plugin This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via self.settings , and access storage through self.storage , but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. Returns: Type Description None None Source code in machine/asyncio/plugins/base.py 43 44 45 46 47 48 49 50 51 52 53 def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass","title":"init()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.users","text":"Dictionary of all users in the Slack workspace Returns: Type Description dict [ str , User ] a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class: ~machine.models.user.User object Source code in machine/asyncio/plugins/base.py 55 56 57 58 59 60 61 62 @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a :py:class:`~machine.models.user.User` object \"\"\" return self . _client . users","title":"users()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.channels","text":"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. Returns: Type Description dict [ str , Channel ] a list of all channels in the Slack workspace, where each channel is a :py:class: ~machine.models.channel.Channel object Source code in machine/asyncio/plugins/base.py 64 65 66 67 68 69 70 71 72 73 74 75 @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels","title":"channels()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.find_channel_by_name","text":"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. Parameters: Name Type Description Default channel_name str The name of the channel to retrieve. required Returns: Type Description Channel | None The channel if found, None otherwise. Source code in machine/asyncio/plugins/base.py 77 78 79 80 81 82 83 84 85 86 87 88 def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None","title":"find_channel_by_name()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.bot_info","text":"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine Returns: Type Description dict [ str , Any ] Bot user Source code in machine/asyncio/plugins/base.py 90 91 92 93 94 95 96 97 98 99 @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info","title":"bot_info()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.at","text":"Create a mention of the provided user Create a mention of the provided user in the form of <@[user_id]> . This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth: ~machine.plugins.base.MachineBasePlugin.say Parameters: Name Type Description Default user User user your want to mention required Returns: Type Description str user mention Source code in machine/asyncio/plugins/base.py 101 102 103 104 105 106 107 108 109 110 111 112 def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention ()","title":"at()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.say","text":"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral_user takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral_user User | str | None optional user name or id if the message needs to visible to a specific user only None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral_user is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/asyncio/plugins/base.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.react","text":"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required ts str timestamp of the message to react to required emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/asyncio/plugins/base.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji )","title":"react()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.send_dm","text":"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default user User | str :py:class: ~machine.models.user.User object or id of user to send DM to. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/asyncio/plugins/base.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs )","title":"send_dm()"},{"location":"api/api-async/#machine.asyncio.plugins.base.MachineBasePlugin.emit","text":"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. Parameters: Name Type Description Default event str name of the event required kwargs any data you want to emit with the event required Returns: Type Description None None Source code in machine/asyncio/plugins/base.py 211 212 213 214 215 216 217 218 219 220 221 def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs )","title":"emit()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message","text":"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The Message class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. Source code in machine/asyncio/plugins/base.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 class Message : \"\"\"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The ``Message`` class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. \"\"\" # TODO: create proper class for msg_event def __init__ ( self , client : SlackClient , msg_event : dict [ str , Any ], plugin_class_name : str ): self . _client = client self . _msg_event = msg_event self . _fq_plugin_name = plugin_class_name @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] @property def is_dm ( self ) -> bool : channel_id = self . _msg_event [ \"channel\" ] return not ( channel_id . startswith ( \"C\" ) or channel_id . startswith ( \"G\" )) @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) def _create_reply ( self , text : str | None ) -> str | None : if not self . is_dm and text is not None : return f \" { self . at_sender } : { text } \" else : return text @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event def __str__ ( self ) -> str : if self . channel . is_im : message = f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in DM\" else : message = \"Message ' {} ', sent by user @ {} in channel # {} \" . format ( self . text , self . sender . profile . real_name , self . channel . name ) return message def __repr__ ( self ) -> str : return \"Message(text= {} , sender= {} , channel= {} )\" . format ( repr ( self . text ), repr ( self . sender . profile . real_name ), repr ( self . channel . name ) )","title":"Message"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.sender","text":"The sender of the message Returns: Type Description User the User the message was sent by Source code in machine/asyncio/plugins/base.py 241 242 243 244 245 246 247 @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]]","title":"sender()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.channel","text":"The channel the message was sent to Returns: Type Description Channel the Channel the message was sent to Source code in machine/asyncio/plugins/base.py 249 250 251 252 253 254 255 @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]]","title":"channel()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.text","text":"The body of the actual message Returns: Type Description str the body (text) of the actual message Source code in machine/asyncio/plugins/base.py 262 263 264 265 266 267 268 @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ]","title":"text()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.at_sender","text":"The sender of the message formatted as mention Returns: Type Description str a string representation of the sender of the message, formatted as mention _, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users Source code in machine/asyncio/plugins/base.py 270 271 272 273 274 275 276 277 278 279 @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention ()","title":"at_sender()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.say","text":"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/asyncio/plugins/base.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.reply","text":"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using blocks and/or attachments is possible. You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over in_thread Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/asyncio/plugins/base.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs )","title":"reply()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.reply_dm","text":"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/asyncio/plugins/base.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs )","title":"reply_dm()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.react","text":"React to the original message Add a reaction to the original message Parameters: Name Type Description Default emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/asyncio/plugins/base.py 408 409 410 411 412 413 414 415 416 417 418 async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji )","title":"react()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.ts","text":"The timestamp of the message Returns: Type Description str the timestamp of the message Source code in machine/asyncio/plugins/base.py 426 427 428 429 430 431 432 @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ]","title":"ts()"},{"location":"api/api-async/#machine.asyncio.plugins.base.Message.in_thread","text":"Is message in a thread Returns: Type Description bool bool Source code in machine/asyncio/plugins/base.py 434 435 436 437 438 439 440 @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event","title":"in_thread()"},{"location":"api/api-async/#decorators","text":"These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.)","title":"Decorators"},{"location":"api/api-async/#machine.asyncio.plugins.decorators","text":"","title":"decorators"},{"location":"api/api-async/#machine.asyncio.plugins.decorators.process","text":"Process Slack events of a specific type This decorator will enable a Plugin method to process Slack events _ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events Parameters: Name Type Description Default slack_event_type str type of event the method needs to process. Can be any event supported by the RTM API required Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/asyncio/plugins/decorators.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def process ( slack_event_type : str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Process Slack events of a specific type This decorator will enable a Plugin method to process `Slack events`_ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events :param slack_event_type: type of event the method needs to process. Can be any event supported by the RTM API :return: wrapped method \"\"\" def process_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . process . append ( slack_event_type ) return fn return process_decorator","title":"process()"},{"location":"api/api-async/#machine.asyncio.plugins.decorators.listen_to","text":"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/asyncio/plugins/decorators.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def listen_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def listen_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . listen_to . append ( re . compile ( regex , flags )) return fn return listen_to_decorator","title":"listen_to()"},{"location":"api/api-async/#machine.asyncio.plugins.decorators.respond_to","text":"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/asyncio/plugins/decorators.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def respond_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :return: wrapped method \"\"\" def respond_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . respond_to . append ( re . compile ( regex , flags )) return fn return respond_to_decorator","title":"respond_to()"},{"location":"api/api-async/#machine.asyncio.plugins.decorators.on","text":"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. Parameters: Name Type Description Default event str name of the event to listen for. Event names are global required Source code in machine/asyncio/plugins/decorators.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def on ( event : str ) -> Callable [[ Callable [ P , R ]], Callable [ P , R ]]: \"\"\"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. :param event: name of the event to listen for. Event names are global \"\"\" def on_decorator ( f : Callable [ P , R ]) -> Callable [ P , R ]: ee . add_listener ( event , f ) return f return on_decorator","title":"on()"},{"location":"api/api-async/#machine.asyncio.plugins.decorators.required_settings","text":"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. Parameters: Name Type Description Default settings list [ str ] | str settings that are required (can be list of strings, or single string) required Source code in machine/asyncio/plugins/decorators.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def required_settings ( settings : list [ str ] | str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. :param settings: settings that are required (can be list of strings, or single string) \"\"\" def required_settings_decorator ( f_or_cls : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: casted_f_or_cls = cast ( DecoratedPluginFunc , f_or_cls ) casted_f_or_cls . metadata = getattr ( f_or_cls , \"metadata\" , Metadata ()) if isinstance ( settings , list ): casted_f_or_cls . metadata . required_settings . extend ( settings ) elif isinstance ( settings , str ): casted_f_or_cls . metadata . required_settings . append ( settings ) return casted_f_or_cls return required_settings_decorator","title":"required_settings()"},{"location":"api/api-async/#machine.asyncio.plugins.decorators.require_any_role","text":"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/asyncio/plugins/decorators.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def require_any_role ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ): logger . debug ( f \"User { msg . sender } has one of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have any of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ANY , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle","title":"require_any_role()"},{"location":"api/api-async/#machine.asyncio.plugins.decorators.require_all_roles","text":"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/asyncio/plugins/decorators.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def require_all_roles ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ) == len ( required_roles ): logger . debug ( f \"User { msg . sender } has all of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have all of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ALL , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle","title":"require_all_roles()"},{"location":"api/api-async/#models","text":"These classes represent base objects from the Slack API","title":"Models"},{"location":"api/api-async/#machine.asyncio.models.user.User","text":"User model that represents a user object from the Slack API Source code in machine/asyncio/models/user.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass ( frozen = True ) class User : \"\"\" User model that represents a user object from the Slack API \"\"\" id : str team_id : Optional [ str ] name : str deleted : Optional [ bool ] profile : Profile is_bot : bool updated : int is_app_user : bool color : Optional [ str ] = None real_name : Optional [ str ] = None tz : Optional [ str ] = None tz_label : Optional [ str ] = None tz_offset : Optional [ int ] = None is_admin : Optional [ bool ] = None is_owner : Optional [ bool ] = None is_primary_owner : Optional [ bool ] = None is_restricted : Optional [ bool ] = None is_ultra_restricted : Optional [ bool ] = None is_stranger : Optional [ bool ] = None has_2fa : Optional [ bool ] = None locale : Optional [ str ] = None @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"User\" : return from_dict ( data_class = User , data = user_reponse ) # pragma: no cover def fmt_mention ( self ) -> str : return f \"<@ { self . id } >\"","title":"User"},{"location":"api/api-async/#machine.asyncio.models.channel.Channel","text":"Channel model that represents a channel object from the Slack API Source code in machine/asyncio/models/channel.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @dataclass ( frozen = True ) class Channel : \"\"\" Channel model that represents a channel object from the Slack API \"\"\" id : str name : Optional [ str ] created : int creator : Optional [ str ] is_archived : bool is_general : Optional [ bool ] name_normalized : Optional [ str ] is_shared : Optional [ bool ] is_org_shared : bool is_member : Optional [ bool ] is_private : Optional [ bool ] is_mpim : Optional [ bool ] is_channel : Optional [ bool ] is_group : Optional [ bool ] is_im : Optional [ bool ] user : Optional [ str ] topic : Optional [ PurposeTopic ] purpose : Optional [ PurposeTopic ] previous_names : Optional [ List [ str ]] @property def identifier ( self ) -> str : if self . name : return self . name else : return self . id @staticmethod def from_api_response ( user_reponse : Dict [ str , Any ]) -> \"Channel\" : return from_dict ( data_class = Channel , data = user_reponse )","title":"Channel"},{"location":"api/api-async/#storage","text":"Storage is exposed to plugins through the self.storage field. The following class implements the interface plugins can use to interact with the storage backend.","title":"Storage"},{"location":"api/api-async/#machine.asyncio.storage.PluginStorage","text":"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using self.storage . Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by dill _, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill Source code in machine/asyncio/storage/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PluginStorage : \"\"\"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using ``self.storage``. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by `dill`_, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill \"\"\" def __init__ ( self , fq_plugin_name : str , storage_backend : MachineBaseStorage ): self . _fq_plugin_name = fq_plugin_name self . _storage = storage_backend def _gen_unique_key ( self , key : str ) -> str : return f \" { self . _fq_plugin_name } : { key } \" def _namespace_key ( self , key : str , shared : bool = False ) -> str : return key if shared else self . _gen_unique_key ( key ) async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires ) async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key ) async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key ) async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size () async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size )","title":"PluginStorage"},{"location":"api/api-async/#machine.asyncio.storage.PluginStorage.set","text":"Store or update a value by key Parameters: Name Type Description Default key str the key under which to store the data required value Any the data to store required expires int | timedelta | None optional number of seconds after which the data is expired None shared bool True/False wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. False Source code in machine/asyncio/storage/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires )","title":"set()"},{"location":"api/api-async/#machine.asyncio.storage.PluginStorage.get","text":"Retrieve data by key Parameters: Name Type Description Default key str key for the data to retrieve required shared bool True/False wether to retrieve data from the shared (global) namespace. False Returns: Type Description Any | None the data, or None if the key cannot be found/has expired Source code in machine/asyncio/storage/__init__.py 47 48 49 50 51 52 53 54 55 56 57 58 59 async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None","title":"get()"},{"location":"api/api-async/#machine.asyncio.storage.PluginStorage.has","text":"Check if the key exists in storage Note: this class implements __contains__ so instead of calling self.storage.has(...) , you can also use: key in self.storage . This will check the namespaced version of the key, so it's the same as: self.storage.has('key', shared=False) Parameters: Name Type Description Default key str key to check required shared bool True/False wether to check in the shared (global) namespace False Returns: Type Description bool True/False wether the key exists. Can only return True if the key has not expired. Source code in machine/asyncio/storage/__init__.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key )","title":"has()"},{"location":"api/api-async/#machine.asyncio.storage.PluginStorage.delete","text":"Remove a key and its data from storage Parameters: Name Type Description Default key str key to remove required shared bool True/False wether the key to remove should be in the shared (global) namespace False Source code in machine/asyncio/storage/__init__.py 77 78 79 80 81 82 83 84 85 async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key )","title":"delete()"},{"location":"api/api-async/#machine.asyncio.storage.PluginStorage.get_storage_size","text":"Calculate the total size of the storage Returns: Type Description int the total size of the storage in bytes (integer) Source code in machine/asyncio/storage/__init__.py 87 88 89 90 91 92 async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size ()","title":"get_storage_size()"},{"location":"api/api-async/#machine.asyncio.storage.PluginStorage.get_storage_size_human","text":"Calculate the total size of the storage in human readable format Returns: Type Description str the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. Source code in machine/asyncio/storage/__init__.py 94 95 96 97 98 99 100 101 async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size ) New Storage Backends can be implemented by extending the following class:","title":"get_storage_size_human()"},{"location":"api/api-async/#machine.asyncio.storage.backends.base.MachineBaseStorage","text":"Bases: ABC Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these: Serialization/Deserialization of data Namespacing of keys (so data stored by different plugins doesn't clash) Source code in machine/asyncio/storage/backends/base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class MachineBaseStorage ( ABC ): \"\"\"Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends **do not** have to deal with the following, because Slack Machine takes care of these: - Serialization/Deserialization of data - Namespacing of keys (so data stored by different plugins doesn't clash) \"\"\" settings : dict [ str , Any ] def __init__ ( self , settings : dict [ str , Any ]): self . settings = settings @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ... @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ... @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ... @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ... @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ... @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ...","title":"MachineBaseStorage"},{"location":"api/api-async/#machine.asyncio.storage.backends.base.MachineBaseStorage.get","text":"Retrieve data by key Parameters: Name Type Description Default key str key for which to retrieve data required Returns: Type Description bytes | None the raw data for the provided key, as (byte)string. Should return None when the key is unknown or the data has expired. Source code in machine/asyncio/storage/backends/base.py 22 23 24 25 26 27 28 29 30 @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ...","title":"get()"},{"location":"api/api-async/#machine.asyncio.storage.backends.base.MachineBaseStorage.set","text":"Store data by key Parameters: Name Type Description Default key str the key under which to store the data required value bytes data as (byte)string required expires int | None optional expiration time in seconds, after which the data should not be returned any more. None Source code in machine/asyncio/storage/backends/base.py 32 33 34 35 36 37 38 39 40 41 @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ...","title":"set()"},{"location":"api/api-async/#machine.asyncio.storage.backends.base.MachineBaseStorage.delete","text":"Delete data by key Parameters: Name Type Description Default key str key for which to delete the data required Source code in machine/asyncio/storage/backends/base.py 43 44 45 46 47 48 49 @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ...","title":"delete()"},{"location":"api/api-async/#machine.asyncio.storage.backends.base.MachineBaseStorage.has","text":"Check if the key exists Parameters: Name Type Description Default key str key to check required Returns: Type Description bool True/False wether the key exists Source code in machine/asyncio/storage/backends/base.py 51 52 53 54 55 56 57 58 @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ...","title":"has()"},{"location":"api/api-async/#machine.asyncio.storage.backends.base.MachineBaseStorage.size","text":"Calculate the total size of the storage Returns: Type Description int total size of storage in bytes (integer) Source code in machine/asyncio/storage/backends/base.py 60 61 62 63 64 65 66 @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ...","title":"size()"},{"location":"api/api-async/#machine.asyncio.storage.backends.base.MachineBaseStorage.close","text":"Close the storage backend Source code in machine/asyncio/storage/backends/base.py 68 69 70 71 @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ...","title":"close()"},{"location":"plugins/basics/","text":"Plugin Basics Writing plugins for Slack Machine is easy. To show you how easy, we'll build and run a simple plugin from start to finish. To be able to follow this guide, you have to have installed and configured Slack Machine first! The Base class for plugins Plugins in Slack Machine are classes that subclass MachineBasePlugin . Inheriting from this class tells Slack Machine that we're dealing with a plugin. But that's not even the most exciting part! With this base class, your plugin immediately has a lot of functionality at its disposal that makes it super easy to do anything from talking to channels, responding to messages, sending DMs, and much more! The decorators Being able to talk in Slack is only half the story for plugins. The functions in your plugin have to be triggered somehow. Slack Machine provides Decorators for that. You can decorate the functions in your plugin class to tell them what they should react to. As an example, let's create a cool plugin! Step 1: Creating the plugin We're going to create a plugin that listens for The Answer , and responds in kind. In the root of your bot (where your local_settings.py lives), create a plugins folder. In it, create an __init__.py (so your plugins folder becomes a package) and a file named hitchhikers.py . Your folder structure should look like this: \u251c\u2500\u2500 local_settings.py \u2514\u2500\u2500 plugins \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 hitchhikers.py Step 2: Adding the code First, we should import the MachineBasePlugin in our code, and the decorator to listen for specific messages. Then we can create our plugin class that includes a function that listens for The Answer, and responds to it: from machine.plugins.base import MachineBasePlugin from machine.plugins.decorators import listen_to import re class UltimateQuestionPlugin ( MachineBasePlugin ): @listen_to ( regex = r '^42$' ) def question ( self , msg ): msg . say ( \"You're telling me the Answer to the Ultimate Question of Life, \" \"the Universe and Everything, but I don't know the question :cry:\" ) Step 3: Enabling our plugin Now we can enable our plugin in our configuration file. Your local_settings.py should look like this: SLACK_API_TOKEN = 'xoxb-something-something' PLUGINS = [ 'machine.plugins.builtin.general.HelloPlugin' , 'machine.plugins.builtin.general.PingPongPlugin' , 'plugins.hitchhikers.UltimateQuestionPlugin' ] Step 4: Run that bot! To run your bot with the new plugin: $ slack-machine That's all there is to it!","title":"Plugin Basics"},{"location":"plugins/basics/#plugin-basics","text":"Writing plugins for Slack Machine is easy. To show you how easy, we'll build and run a simple plugin from start to finish. To be able to follow this guide, you have to have installed and configured Slack Machine first!","title":"Plugin Basics"},{"location":"plugins/basics/#the-base-class-for-plugins","text":"Plugins in Slack Machine are classes that subclass MachineBasePlugin . Inheriting from this class tells Slack Machine that we're dealing with a plugin. But that's not even the most exciting part! With this base class, your plugin immediately has a lot of functionality at its disposal that makes it super easy to do anything from talking to channels, responding to messages, sending DMs, and much more!","title":"The Base class for plugins"},{"location":"plugins/basics/#the-decorators","text":"Being able to talk in Slack is only half the story for plugins. The functions in your plugin have to be triggered somehow. Slack Machine provides Decorators for that. You can decorate the functions in your plugin class to tell them what they should react to. As an example, let's create a cool plugin!","title":"The decorators"},{"location":"plugins/basics/#step-1-creating-the-plugin","text":"We're going to create a plugin that listens for The Answer , and responds in kind. In the root of your bot (where your local_settings.py lives), create a plugins folder. In it, create an __init__.py (so your plugins folder becomes a package) and a file named hitchhikers.py . Your folder structure should look like this: \u251c\u2500\u2500 local_settings.py \u2514\u2500\u2500 plugins \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 hitchhikers.py","title":"Step 1: Creating the plugin"},{"location":"plugins/basics/#step-2-adding-the-code","text":"First, we should import the MachineBasePlugin in our code, and the decorator to listen for specific messages. Then we can create our plugin class that includes a function that listens for The Answer, and responds to it: from machine.plugins.base import MachineBasePlugin from machine.plugins.decorators import listen_to import re class UltimateQuestionPlugin ( MachineBasePlugin ): @listen_to ( regex = r '^42$' ) def question ( self , msg ): msg . say ( \"You're telling me the Answer to the Ultimate Question of Life, \" \"the Universe and Everything, but I don't know the question :cry:\" )","title":"Step 2: Adding the code"},{"location":"plugins/basics/#step-3-enabling-our-plugin","text":"Now we can enable our plugin in our configuration file. Your local_settings.py should look like this: SLACK_API_TOKEN = 'xoxb-something-something' PLUGINS = [ 'machine.plugins.builtin.general.HelloPlugin' , 'machine.plugins.builtin.general.PingPongPlugin' , 'plugins.hitchhikers.UltimateQuestionPlugin' ]","title":"Step 3: Enabling our plugin"},{"location":"plugins/basics/#step-4-run-that-bot","text":"To run your bot with the new plugin: $ slack-machine That's all there is to it!","title":"Step 4: Run that bot!"},{"location":"plugins/interacting/","text":"How to interact Slack Machine provides several convenient ways to interact with channels and users in your Slack workspace. To this end, two very similar sets of functions are exposed through two classes: MachineBasePlugin The MachineBasePlugin class every plugin extends, provides methods to send messages to channels (public, private and DM), through the RTM API or using the WebAPI (for rich messages/attachment support). It also supports adding reactions to messages, replying in-thread, sending ephemeral messages to a channel (only visible to 1 user), and much more. Message An instance of the Message class is automatically supplied to your plugin functions when using the @respond_to or @respond_to decorators. It has a similar set of methods as the MachineBasePlugin class, but without the need to manually specify the channel you want to talk to. It lets you send messages and reply to messages in the same channel the original message was received in. It is recommended to use the passed-in Message object to interact with channels and users, whenever you use the @respond_to or @respond_to decorators, as this takes away the pain of having to manually target the right channels. For a detailed description of all the methods available to you, please read the api documentation . What follows are some examples of how you would respond in common scenarios. Responding to a message If your plugin receives a message through the @respond_to or @listen_to decorators, the simplest way to reply is using msg.reply() . It takes 2 parameters: text : the message you want to send in_thread : if Slack Machine should reply to the original message in-thread msg.reply() will start the reply with a mention of the sender of the original message. Example: @respond_to ( r \"^I love you\" ) def spread_love ( self , msg ): msg . reply ( \"I love you too!\" ) If this function is triggered by a message @superbot I love you , sent by @john , the response will be: @john: I love you too! msg.reply() will use the Slack WebAPI to send messages, which means you can send richly formatted messages using blocks and/or attachments . The underlying Python slackclient that Slack Machine uses, provides some convenience classes that can help with creating blocks or attachments. All Slack Machine methods that can be used to send messages, accept lists of Block objects and/or Attachment objects from the aforementioned convience classes. This method has 2 extra parameters that unlock 2 extra features: ephemeral : if True , the message will be visible only to the sender of the original message. in_thread : this will send the message in a thread instead of to the main channel There is 1 more method to respond to a message in the same channel: msg.say() is very similar to its reply counterpart, with the exception that it won't mention the sender of the original message. If you want to reply to the sender of the original message in a DM instead of in the original channel, you can use the msg.reply_dm() methods. This will open a DM convo between the sender of the original message and the bot (if it doesn't exist already) and send a message there. If the original message was already received in a DM channel, this is no different from using reply() . Message properties The Message object your plugin function receives, has some convenient properties about the message that triggered the function: sender : a User object with information about the sender, such as their id and name channel : a Channel object with information about the channel the message was received in text : the contents of the original message Plugin properties The MachineBasePlugin class every plugin extends, exposes some properties about your Slack workspace. These properties are not filled when your plugin is instantiated, but reflect the current status of the Slack client: users : a dict of user ids and the associated User objects for all users that Slack Machine knows about. This is usually all the active users in your Slack workspace. This data structure is filled when Slack Machine starts and is automatically updated whenever a new user joins or the properties of a user change. channels : a dict of channel ids and the associated User objects for channels that Slack Machine knows about. This contains all the public channels in your Slack workspace, plus all private channels that your Slack Machine instance was invited to. Sending messages without a msg object There are situations in which you want to send messages to users/channels, but there is no original message to respond to. For example when implementing your own event listener using the @process decorator. In this case you can call functions similar as those described before, but from your plugin itself: self.say() , self.send_dm() and These behave similar to their Message counterparts, except that they require a channel id or object, or user id or object (in case of DM) to be passed in. Scheduling messages Sometimes you want to reply to a message, send a message to some channel, send a DM etc. but you don't want to do it now . You want to do it in the future . Slack Machine provides scheduled versions of many methods, both in the MachineBasePlugin all plugins extend from and in the Message object @respond_to and @respond_to functions receive. These methods can be recognized by their _scheduled prefix. They work almost the same as their regular counterparts, except that they receive 1 extra argument: a datetime object that tells Slack Machine when to send the message. Example: @respond_to ( r \"greet me in the future\" ) def future ( self , msg ): msg . say ( \"command received!\" ) in_10_sec = datetime . now () + timedelta ( seconds = 10 ) msg . reply_dm_scheduled ( in_10_sec , \"A Delayed Hello!\" ) This function will send a greeting 10 seconds after it has received a message: @superbot greet me in the future . Ceveat You cannot schedule a reaction to a message. It doesn't make sense to react to a message in the future. For more information about scheduling message, have a look at the api documentation . Protecting commands Sometimes you may want to restrict certain commands in your bot, so they can only be invoked by certain users. To use these restrictions you must appoint one user to be the root user . For security reasons there can be only one root user , and it must be configured through local_settings.py or environment variables. That way you will never lose control over your bot. To enable all the role based features, your local_settings.py would look something like this: SLACK_API_TOKEN = 'xoxb-my-slack-token' ROOT_USER = 'U0000007' PLUGINS = [ 'machine.plugins.builtin.admin.RBACPlugin' , ] You can get the member ID from a user by going to their Slack profile, clicking more and selecting Copy member ID . If you wish to share the powers of root you can enable the RBAC admin plugin RBACPlugin and grant the admin role to users you trust. The RBAC plugin provides you with three new commands that lets you lookup, grant and revoke roles to users: @superbot who has role admin @superbot grant role admin to @trusted-user @superbot revoke role admin from @trusted-user . Now you can decorate certain functions in your plugin with the @require_any_role or @require_all_roles decorators to make them only usable by users with certain roles. Here is an example of a command that requires either the admin or channel role: @respond_to ( r \"^say in\" r '\\s+<#\\w+\\|(?P<channel_name>[^>]+)>' r '\\s+(?P<message>.+)' ) @require_any_role ([ 'admin' , 'channel' ]) def say_in_channel ( self , msg , channel_name , message ): logging . info ( channel_name ) self . say ( channel_name , message ) You can define as many roles as you want, any string without spaces is acceptable. Emitting events Your plugin can emit arbitrary events that other plugins (or your own) can listen for. Events are a convenient mechanism for exchanging data between plugins and/or for a plugin to expose an api that other plugins can hook into. Emitting an event is done with self.emit() . You have to provide a name for the event you want to emit, so others can listen for an event by that name. You can optionally provide extra data as keyword arguments. Example: @respond_to ( r \"I have used the bathroom\" ) def broadcast_bathroom_usage ( self , msg ): self . emit ( 'bathroom_used' , toilet_flushed = True ) You can read the events section to see how your plugin can listen for events.","title":"How to interact"},{"location":"plugins/interacting/#how-to-interact","text":"Slack Machine provides several convenient ways to interact with channels and users in your Slack workspace. To this end, two very similar sets of functions are exposed through two classes:","title":"How to interact"},{"location":"plugins/interacting/#machinebaseplugin","text":"The MachineBasePlugin class every plugin extends, provides methods to send messages to channels (public, private and DM), through the RTM API or using the WebAPI (for rich messages/attachment support). It also supports adding reactions to messages, replying in-thread, sending ephemeral messages to a channel (only visible to 1 user), and much more.","title":"MachineBasePlugin"},{"location":"plugins/interacting/#message","text":"An instance of the Message class is automatically supplied to your plugin functions when using the @respond_to or @respond_to decorators. It has a similar set of methods as the MachineBasePlugin class, but without the need to manually specify the channel you want to talk to. It lets you send messages and reply to messages in the same channel the original message was received in. It is recommended to use the passed-in Message object to interact with channels and users, whenever you use the @respond_to or @respond_to decorators, as this takes away the pain of having to manually target the right channels. For a detailed description of all the methods available to you, please read the api documentation . What follows are some examples of how you would respond in common scenarios.","title":"Message"},{"location":"plugins/interacting/#responding-to-a-message","text":"If your plugin receives a message through the @respond_to or @listen_to decorators, the simplest way to reply is using msg.reply() . It takes 2 parameters: text : the message you want to send in_thread : if Slack Machine should reply to the original message in-thread msg.reply() will start the reply with a mention of the sender of the original message. Example: @respond_to ( r \"^I love you\" ) def spread_love ( self , msg ): msg . reply ( \"I love you too!\" ) If this function is triggered by a message @superbot I love you , sent by @john , the response will be: @john: I love you too! msg.reply() will use the Slack WebAPI to send messages, which means you can send richly formatted messages using blocks and/or attachments . The underlying Python slackclient that Slack Machine uses, provides some convenience classes that can help with creating blocks or attachments. All Slack Machine methods that can be used to send messages, accept lists of Block objects and/or Attachment objects from the aforementioned convience classes. This method has 2 extra parameters that unlock 2 extra features: ephemeral : if True , the message will be visible only to the sender of the original message. in_thread : this will send the message in a thread instead of to the main channel There is 1 more method to respond to a message in the same channel: msg.say() is very similar to its reply counterpart, with the exception that it won't mention the sender of the original message. If you want to reply to the sender of the original message in a DM instead of in the original channel, you can use the msg.reply_dm() methods. This will open a DM convo between the sender of the original message and the bot (if it doesn't exist already) and send a message there. If the original message was already received in a DM channel, this is no different from using reply() .","title":"Responding to a message"},{"location":"plugins/interacting/#message-properties","text":"The Message object your plugin function receives, has some convenient properties about the message that triggered the function: sender : a User object with information about the sender, such as their id and name channel : a Channel object with information about the channel the message was received in text : the contents of the original message","title":"Message properties"},{"location":"plugins/interacting/#plugin-properties","text":"The MachineBasePlugin class every plugin extends, exposes some properties about your Slack workspace. These properties are not filled when your plugin is instantiated, but reflect the current status of the Slack client: users : a dict of user ids and the associated User objects for all users that Slack Machine knows about. This is usually all the active users in your Slack workspace. This data structure is filled when Slack Machine starts and is automatically updated whenever a new user joins or the properties of a user change. channels : a dict of channel ids and the associated User objects for channels that Slack Machine knows about. This contains all the public channels in your Slack workspace, plus all private channels that your Slack Machine instance was invited to.","title":"Plugin properties"},{"location":"plugins/interacting/#sending-messages-without-a-msg-object","text":"There are situations in which you want to send messages to users/channels, but there is no original message to respond to. For example when implementing your own event listener using the @process decorator. In this case you can call functions similar as those described before, but from your plugin itself: self.say() , self.send_dm() and These behave similar to their Message counterparts, except that they require a channel id or object, or user id or object (in case of DM) to be passed in.","title":"Sending messages without a msg object"},{"location":"plugins/interacting/#scheduling-messages","text":"Sometimes you want to reply to a message, send a message to some channel, send a DM etc. but you don't want to do it now . You want to do it in the future . Slack Machine provides scheduled versions of many methods, both in the MachineBasePlugin all plugins extend from and in the Message object @respond_to and @respond_to functions receive. These methods can be recognized by their _scheduled prefix. They work almost the same as their regular counterparts, except that they receive 1 extra argument: a datetime object that tells Slack Machine when to send the message. Example: @respond_to ( r \"greet me in the future\" ) def future ( self , msg ): msg . say ( \"command received!\" ) in_10_sec = datetime . now () + timedelta ( seconds = 10 ) msg . reply_dm_scheduled ( in_10_sec , \"A Delayed Hello!\" ) This function will send a greeting 10 seconds after it has received a message: @superbot greet me in the future . Ceveat You cannot schedule a reaction to a message. It doesn't make sense to react to a message in the future. For more information about scheduling message, have a look at the api documentation .","title":"Scheduling messages"},{"location":"plugins/interacting/#protecting-commands","text":"Sometimes you may want to restrict certain commands in your bot, so they can only be invoked by certain users. To use these restrictions you must appoint one user to be the root user . For security reasons there can be only one root user , and it must be configured through local_settings.py or environment variables. That way you will never lose control over your bot. To enable all the role based features, your local_settings.py would look something like this: SLACK_API_TOKEN = 'xoxb-my-slack-token' ROOT_USER = 'U0000007' PLUGINS = [ 'machine.plugins.builtin.admin.RBACPlugin' , ] You can get the member ID from a user by going to their Slack profile, clicking more and selecting Copy member ID . If you wish to share the powers of root you can enable the RBAC admin plugin RBACPlugin and grant the admin role to users you trust. The RBAC plugin provides you with three new commands that lets you lookup, grant and revoke roles to users: @superbot who has role admin @superbot grant role admin to @trusted-user @superbot revoke role admin from @trusted-user . Now you can decorate certain functions in your plugin with the @require_any_role or @require_all_roles decorators to make them only usable by users with certain roles. Here is an example of a command that requires either the admin or channel role: @respond_to ( r \"^say in\" r '\\s+<#\\w+\\|(?P<channel_name>[^>]+)>' r '\\s+(?P<message>.+)' ) @require_any_role ([ 'admin' , 'channel' ]) def say_in_channel ( self , msg , channel_name , message ): logging . info ( channel_name ) self . say ( channel_name , message ) You can define as many roles as you want, any string without spaces is acceptable.","title":"Protecting commands"},{"location":"plugins/interacting/#emitting-events","text":"Your plugin can emit arbitrary events that other plugins (or your own) can listen for. Events are a convenient mechanism for exchanging data between plugins and/or for a plugin to expose an api that other plugins can hook into. Emitting an event is done with self.emit() . You have to provide a name for the event you want to emit, so others can listen for an event by that name. You can optionally provide extra data as keyword arguments. Example: @respond_to ( r \"I have used the bathroom\" ) def broadcast_bathroom_usage ( self , msg ): self . emit ( 'bathroom_used' , toilet_flushed = True ) You can read the events section to see how your plugin can listen for events.","title":"Emitting events"},{"location":"plugins/listening/","text":"Listening for things Slack Machine allows you to listen for various different things and respond to that. By decorating functions in your plugin using the decorators-section Slack Machine provides, you can tell Slack Machine to run those functions when something specific happens. Listen for a mention The respond_to decorator tells Slack Machine to listen for messages mentioning your bot and matching a specific pattern. Slack Machine will hear messages sent in any channel or private group it is a member of. For a message to trigger a function decorated by @respond_to(...) , the message has to start with a mention of your bot or with any alias the user configured using the ALIASES setting. The exception is direct messages sent to the bot, they don't have to include a mention to trigger @respond_to . @respond_to takes 2 parameters: regex ( required ): the regular expression Slack Machine should listen for. The regex pattern should not account for the mention of your bot, as Slack Machine will remove the mention before looking for a match. Slack Machine listens for any occurrence of the pattern in the message, so if you want to specifically match the whole message, you can anchor your pattern using the ^ and $ symbols. flags (optional): can be used to pass flags for the regex matching as defined in the re module. By default, re.IGNORECASE is applied. How your function will be called Your function will be called with a Message object that represents the message that triggered the function. It not only contains the message text itself, but also has many convenient methods for replying. Example: @respond_to ( r \"^I love you\" ) def spread_love ( self , msg ): msg . reply ( \"I love you too!\" ) The regex pattern can optionally contain named groups that will be captured and passed to your function as keyword arguments. Example: @respond_to ( r \"You deserve (?P<num_stars>\\d+) stars!\" ) def award ( self , msg , num_stars ): stars_back = int ( num_stars ) + 1 msg . reply ( \"Well, you deserve {} !\" . format ( stars_back )) Hear any message The @listen_to decorator works similar as the @respond_to decorator, but it will hear any message matching a pattern, without the bot being explicitly mentioned. @listen_to takes the same parameters as @respond_to . Example: @listen_to ( r \"go for it\" ) @listen_to ( r \"go 4 it\" ) def go_for_it ( self , msg ): msg . say ( \"https://a-z-animals.com/media/animals/images/original/gopher_2.jpg\" ) As you can see, you can also apply the same decorator multiple times to a function, each time with different arguments. Of course, you can also combine different decorators on one function. More flexibility with Slack events If you want your bot to respond to other things than messages, you can do so using the @process decorator. @process requires an event_type as parameter and will trigger the decorated function any time an event of the specified type happens. It can listen to any Slack event that is supported by the RTM API. The received event will be passed to your function. The following example will listen for the reaction_added event to know if a reaction was added to a message, and will match that reaction: @process ( \"reaction_added\" ) def match_reaction ( self , event ): emoji = event [ 'reaction' ] channel = event [ 'item' ][ 'channel' ] ts = event [ 'item' ][ 'ts' ] self . react ( channel , ts , emoji ) As you can see, @process gives you a lot of flexibility by allowing you to process any event Slack Machine does not provide a specific decorator for. Take action on a Schedule Slack Machine can also run functions on a schedule, using the @schedule decorator. @schedule behaves like Linux/Unix Crontab , and receives similar parameters. You can specify on what schedule your function should be called. When your function is called, it will not receive any arguments except self , but you can of course call any MachineBasePlugin methods to send message and do other things. Example: @schedule ( hour = '9-17' , minute = '*/30' ) def movement_reminder ( self ): self . say ( 'general' , '<!here> maybe now is a good time to take a short walk!' ) Events Slack Machine can respond to events that are emitted by your plugin(s) or plugins of others, or events generated by parts of Slack Machine itself. You can use the @on decorator on a function to run that function whenever a certain event is emitted somewhere. Example: @on ( 'bathroom_used' ) def call_cleaning_department ( self , ** kwargs ): self . say ( 'cleaning-department' , '<!here> Somebody used the toilet!' ) This function will be called whenever the bathroom_used event is emitted somewhere. Some things to be aware of Event names are global, every plugin can emit and listen for the same events. This is by design, because this way, you can use events to exchange data between plugins. Events can be a way to expose a \"public API\" for plugins. But this can also mean your functions are unexpectedly triggered by events sent by other plugins, especially if the event names you choose are very generic. When emitting events, plugins can attach whatever variables they want to the event, and when listening for an event, your function will be called with whatever arguments were attached to the event when the event was emitted. It's therefor a good idea to always include **kwargs as a catch-all, otherwise your function could return an error when it's called with arguments that have not been explicitly defined. You can read emitting events to learn how to emit events from your plugins. HTTP Listener Slack Machine has a built-in HTTP server that can listen for incoming requests. Bottle is used for this feature. You can use the @route decorator to mark functions in your plugin classes to listen for specific HTTP calls. The decorator accepts the same arguments as the Bottle route() decorator. You can return anything that Bottle view functions can return, because your functions will be delegated to the Bottle router. You can of course also use any of the features that the MachineBasePlugin gives you, such as sending a message to a user or a channel. Example: @route ( \"/hello\" ) @route ( \"/hello/<name>\" ) def my_exposed_function ( self , name = \"World\" ): self . say ( 'my-channel' , ' {} is talking to me' . format ( name )) return { \"hello\" : name } # listen to specific HTTP verbs @route ( \"/status\" , method = [ \"POST\" , \"GET\" ]) def my_other_function ( self ): return { \"status\" : \"I'm a-okay!\" } Slack Machine supports any of the server backends that Bottle supports . You can set the name of the server backend you want in your settings as HTTP_SERVER_BACKEND . If you don't need this functionality, you can disable the HTTP server by setting DISABLE_HTTP to True in your settings. The built-in HTTP server which can be configured using the following settings: # Should the HTTP server be enabled? DISABLE_HTTP = False # Which serving backend should `bottle` use? HTTP_SERVER_BACKEND = 'wsgiref' # Host address to listen on HTTP_SERVER_HOST = '0.0.0.0' # Host port to listen on HTTP_SERVER_PORT = 8080","title":"Listening for things"},{"location":"plugins/listening/#listening-for-things","text":"Slack Machine allows you to listen for various different things and respond to that. By decorating functions in your plugin using the decorators-section Slack Machine provides, you can tell Slack Machine to run those functions when something specific happens.","title":"Listening for things"},{"location":"plugins/listening/#listen-for-a-mention","text":"The respond_to decorator tells Slack Machine to listen for messages mentioning your bot and matching a specific pattern. Slack Machine will hear messages sent in any channel or private group it is a member of. For a message to trigger a function decorated by @respond_to(...) , the message has to start with a mention of your bot or with any alias the user configured using the ALIASES setting. The exception is direct messages sent to the bot, they don't have to include a mention to trigger @respond_to . @respond_to takes 2 parameters: regex ( required ): the regular expression Slack Machine should listen for. The regex pattern should not account for the mention of your bot, as Slack Machine will remove the mention before looking for a match. Slack Machine listens for any occurrence of the pattern in the message, so if you want to specifically match the whole message, you can anchor your pattern using the ^ and $ symbols. flags (optional): can be used to pass flags for the regex matching as defined in the re module. By default, re.IGNORECASE is applied.","title":"Listen for a mention"},{"location":"plugins/listening/#how-your-function-will-be-called","text":"Your function will be called with a Message object that represents the message that triggered the function. It not only contains the message text itself, but also has many convenient methods for replying. Example: @respond_to ( r \"^I love you\" ) def spread_love ( self , msg ): msg . reply ( \"I love you too!\" ) The regex pattern can optionally contain named groups that will be captured and passed to your function as keyword arguments. Example: @respond_to ( r \"You deserve (?P<num_stars>\\d+) stars!\" ) def award ( self , msg , num_stars ): stars_back = int ( num_stars ) + 1 msg . reply ( \"Well, you deserve {} !\" . format ( stars_back ))","title":"How your function will be called"},{"location":"plugins/listening/#hear-any-message","text":"The @listen_to decorator works similar as the @respond_to decorator, but it will hear any message matching a pattern, without the bot being explicitly mentioned. @listen_to takes the same parameters as @respond_to . Example: @listen_to ( r \"go for it\" ) @listen_to ( r \"go 4 it\" ) def go_for_it ( self , msg ): msg . say ( \"https://a-z-animals.com/media/animals/images/original/gopher_2.jpg\" ) As you can see, you can also apply the same decorator multiple times to a function, each time with different arguments. Of course, you can also combine different decorators on one function.","title":"Hear any message"},{"location":"plugins/listening/#more-flexibility-with-slack-events","text":"If you want your bot to respond to other things than messages, you can do so using the @process decorator. @process requires an event_type as parameter and will trigger the decorated function any time an event of the specified type happens. It can listen to any Slack event that is supported by the RTM API. The received event will be passed to your function. The following example will listen for the reaction_added event to know if a reaction was added to a message, and will match that reaction: @process ( \"reaction_added\" ) def match_reaction ( self , event ): emoji = event [ 'reaction' ] channel = event [ 'item' ][ 'channel' ] ts = event [ 'item' ][ 'ts' ] self . react ( channel , ts , emoji ) As you can see, @process gives you a lot of flexibility by allowing you to process any event Slack Machine does not provide a specific decorator for.","title":"More flexibility with Slack events"},{"location":"plugins/listening/#take-action-on-a-schedule","text":"Slack Machine can also run functions on a schedule, using the @schedule decorator. @schedule behaves like Linux/Unix Crontab , and receives similar parameters. You can specify on what schedule your function should be called. When your function is called, it will not receive any arguments except self , but you can of course call any MachineBasePlugin methods to send message and do other things. Example: @schedule ( hour = '9-17' , minute = '*/30' ) def movement_reminder ( self ): self . say ( 'general' , '<!here> maybe now is a good time to take a short walk!' )","title":"Take action on a Schedule"},{"location":"plugins/listening/#events","text":"Slack Machine can respond to events that are emitted by your plugin(s) or plugins of others, or events generated by parts of Slack Machine itself. You can use the @on decorator on a function to run that function whenever a certain event is emitted somewhere. Example: @on ( 'bathroom_used' ) def call_cleaning_department ( self , ** kwargs ): self . say ( 'cleaning-department' , '<!here> Somebody used the toilet!' ) This function will be called whenever the bathroom_used event is emitted somewhere. Some things to be aware of Event names are global, every plugin can emit and listen for the same events. This is by design, because this way, you can use events to exchange data between plugins. Events can be a way to expose a \"public API\" for plugins. But this can also mean your functions are unexpectedly triggered by events sent by other plugins, especially if the event names you choose are very generic. When emitting events, plugins can attach whatever variables they want to the event, and when listening for an event, your function will be called with whatever arguments were attached to the event when the event was emitted. It's therefor a good idea to always include **kwargs as a catch-all, otherwise your function could return an error when it's called with arguments that have not been explicitly defined. You can read emitting events to learn how to emit events from your plugins.","title":"Events"},{"location":"plugins/listening/#http-listener","text":"Slack Machine has a built-in HTTP server that can listen for incoming requests. Bottle is used for this feature. You can use the @route decorator to mark functions in your plugin classes to listen for specific HTTP calls. The decorator accepts the same arguments as the Bottle route() decorator. You can return anything that Bottle view functions can return, because your functions will be delegated to the Bottle router. You can of course also use any of the features that the MachineBasePlugin gives you, such as sending a message to a user or a channel. Example: @route ( \"/hello\" ) @route ( \"/hello/<name>\" ) def my_exposed_function ( self , name = \"World\" ): self . say ( 'my-channel' , ' {} is talking to me' . format ( name )) return { \"hello\" : name } # listen to specific HTTP verbs @route ( \"/status\" , method = [ \"POST\" , \"GET\" ]) def my_other_function ( self ): return { \"status\" : \"I'm a-okay!\" } Slack Machine supports any of the server backends that Bottle supports . You can set the name of the server backend you want in your settings as HTTP_SERVER_BACKEND . If you don't need this functionality, you can disable the HTTP server by setting DISABLE_HTTP to True in your settings. The built-in HTTP server which can be configured using the following settings: # Should the HTTP server be enabled? DISABLE_HTTP = False # Which serving backend should `bottle` use? HTTP_SERVER_BACKEND = 'wsgiref' # Host address to listen on HTTP_SERVER_HOST = '0.0.0.0' # Host port to listen on HTTP_SERVER_PORT = 8080","title":"HTTP Listener"},{"location":"plugins/misc/","text":"Miscellaneous stuff This section contains some odds and ends that were not discussed in previous sections. Plugin initialization Plugins are initialized when Slack Machine starts. Because the MachineBasePlugin already has a constructor that is used to pass various things to the plugin instance at startup, it is advised not to provide a constructor for your plugin. If your plugin needs to initialize its own things at startup, you can override the init() method. This method will be called once when the plugin is initialized. It is no-op by default. Plugin help information You can provide help text for your plugin and its commands by adding docstrings to your plugin class and its methods. The first line of the docstring of a plugin class will be used for grouping help information of plugin methods. This even extends beyond one class, ie. if multiple plugin classes have the same docstring (first line), the help information for the methods under those classes will be grouped together. The first line of the docstring of each plugin method can be used for specifying help information for that specific function. It should be in the format command: help text . The machine.plugins.builtin.help.HelpPlugin (enabled by default) will provide Slack users with the help information described above.","title":"Miscellaneous stuff"},{"location":"plugins/misc/#miscellaneous-stuff","text":"This section contains some odds and ends that were not discussed in previous sections.","title":"Miscellaneous stuff"},{"location":"plugins/misc/#plugin-initialization","text":"Plugins are initialized when Slack Machine starts. Because the MachineBasePlugin already has a constructor that is used to pass various things to the plugin instance at startup, it is advised not to provide a constructor for your plugin. If your plugin needs to initialize its own things at startup, you can override the init() method. This method will be called once when the plugin is initialized. It is no-op by default.","title":"Plugin initialization"},{"location":"plugins/misc/#plugin-help-information","text":"You can provide help text for your plugin and its commands by adding docstrings to your plugin class and its methods. The first line of the docstring of a plugin class will be used for grouping help information of plugin methods. This even extends beyond one class, ie. if multiple plugin classes have the same docstring (first line), the help information for the methods under those classes will be grouped together. The first line of the docstring of each plugin method can be used for specifying help information for that specific function. It should be in the format command: help text . The machine.plugins.builtin.help.HelpPlugin (enabled by default) will provide Slack users with the help information described above.","title":"Plugin help information"},{"location":"plugins/settings/","text":"Plugin Settings All settings that are defined, either from the Slack Machine defaults or in local_settings.py are available to plugins through the self.settings field. This is a dictionary with all settings indexed by their name. Next to local_settings.py , users can also specify settings with environment variables. Slack Machine will automatically translate any environment variable with the format SM_<SETTING-NAME> to a setting with name SETTING-NAME , overriding a setting with the same name from local_settings.py or the default settings. So an environment variable SM_SLACK_API_TOKEN will result in a setting SLACK_API_TOKEN . Setting names are case insensitive . Example of using settings When the local_settings.py looks like this: SLACK_API_TOKEN = 'xoxo-abc123' GREETING_PLUGIN_MY_GREETING = 'Bonjour' This can be used in a plugin, like this: @respond_to ( r \"Hello!\" ) def greeting ( self , msg ): msg . reply ( \" {} , {} !\" . format ( self . settings [ 'GREETING_PLUGIN_MY_GREETING' ], msg . at_sender )) The respond to a message \\@superbot Hello!\\\" from \\@john , in this case would be: Bonjour, \\@john! Required settings If your plugin requires one or more settings to be defined in order to work, you can mark them as required with the @required_settings decorator. This decorator takes a string or a list of strings as argument which can be one or more settings that are required by your plugin. Upon startup, Slack Machine will check if any of the settings that are marked as required by a plugin, have not been defined by the user. If it finds one or more missing settings, it will not load that particular plugin, and notify the user which settings are missing. The @required_settings decorator can be applied to a plugin class and/or its methods. Note that if any of the required settings are missing, the plugin will not load as a whole, so none of the methods will be registered. Example: @required_settings ([ 'TODO_SERVICE_USERNAME' , 'TODO_SERVICE_PASSWORD' ]) class TodoPlugin ( MachineBasePlugin ): ...","title":"Plugin Settings"},{"location":"plugins/settings/#plugin-settings","text":"All settings that are defined, either from the Slack Machine defaults or in local_settings.py are available to plugins through the self.settings field. This is a dictionary with all settings indexed by their name. Next to local_settings.py , users can also specify settings with environment variables. Slack Machine will automatically translate any environment variable with the format SM_<SETTING-NAME> to a setting with name SETTING-NAME , overriding a setting with the same name from local_settings.py or the default settings. So an environment variable SM_SLACK_API_TOKEN will result in a setting SLACK_API_TOKEN . Setting names are case insensitive .","title":"Plugin Settings"},{"location":"plugins/settings/#example-of-using-settings","text":"When the local_settings.py looks like this: SLACK_API_TOKEN = 'xoxo-abc123' GREETING_PLUGIN_MY_GREETING = 'Bonjour' This can be used in a plugin, like this: @respond_to ( r \"Hello!\" ) def greeting ( self , msg ): msg . reply ( \" {} , {} !\" . format ( self . settings [ 'GREETING_PLUGIN_MY_GREETING' ], msg . at_sender )) The respond to a message \\@superbot Hello!\\\" from \\@john , in this case would be: Bonjour, \\@john!","title":"Example of using settings"},{"location":"plugins/settings/#required-settings","text":"If your plugin requires one or more settings to be defined in order to work, you can mark them as required with the @required_settings decorator. This decorator takes a string or a list of strings as argument which can be one or more settings that are required by your plugin. Upon startup, Slack Machine will check if any of the settings that are marked as required by a plugin, have not been defined by the user. If it finds one or more missing settings, it will not load that particular plugin, and notify the user which settings are missing. The @required_settings decorator can be applied to a plugin class and/or its methods. Note that if any of the required settings are missing, the plugin will not load as a whole, so none of the methods will be registered. Example: @required_settings ([ 'TODO_SERVICE_USERNAME' , 'TODO_SERVICE_PASSWORD' ]) class TodoPlugin ( MachineBasePlugin ): ...","title":"Required settings"},{"location":"plugins/storage/","text":"Storage Slack Machine provides persistent storage that can easily be accessed from plugins through self.storage . This field contains an instance of PluginStorage , which lets you store, retrieve and remove values by key, check for the existence of a key and get information about the current size of the underlying storage. The PluginStorage class interfaces with whatever storage backend Slack Machine is configured with. You can read more about the available storage backends in the user guide . Example: @respond_to ( r \"store (?P<text>.*) under (?P<key>\\w+)\" ) def store ( self , msg , text , key ): self . storage . set ( key , text ) msg . say ( \"' {} ' stored under {} !\" . format ( text , key )) @respond_to ( r \"retrieve (?P<key>\\w+)\" ) def retrieve ( self , msg , key ): data = self . storage . get ( key ) if data : msg . say ( \"' {} ' retrieved from < {} >!\" . format ( data , key )) else : msg . say ( \"Key not found!\" ) @respond_to ( r \"delete (?P<key>\\w+)\" ) def delete ( self , msg , key ): self . storage . delete ( key ) msg . say ( \"data in < {} > deleted!\" . format ( key )) @respond_to ( r \"does (?P<key>\\w+) exist?\" ) def exists ( self , msg , key ): # if key in self.storage if self . storage . has ( key ): msg . say ( \"< {} > exists.\" . format ( key )) else : msg . say ( \"< {} > does not exist!\" . format ( key )) @respond_to ( r \"size\" ) def size ( self , msg ): human_size = self . storage . get_storage_size_human () msg . say ( \"storage size: {} \" . format ( human_size )) Shared vs non-shared By default, when you store, retrieve and remove data by key, Slack Machine will automatically namespace the keys you use with the fully qualified classname of the plugin the storage is used from. This is done to prevent plugins from changing or even deleting each others data. So when you do this: class MyPlugin : # resides in module my.plugin.package def some_function (): self . set ( 'my-key' , 'my-data' ) Slack Machine will send the key my.plugin.package.MyPlugin:my-key to the storage backend. You can override this behaviour by setting the shared parameter to True when calling a storage related function that requires a key as parameter. This keep the key global (ie. non-namespaced). This is useful when you want to share data between plugins. Use this feature with care though, as you can destroy data that belongs to other plugins! Implementing your own storage backend You can implement your own storage backend by subclassing MachineBaseStorage . You only have to implement a couple of methods, and you don't have to take care of namespacing of keys, as Slack Machine will do that for you.","title":"Storage"},{"location":"plugins/storage/#storage","text":"Slack Machine provides persistent storage that can easily be accessed from plugins through self.storage . This field contains an instance of PluginStorage , which lets you store, retrieve and remove values by key, check for the existence of a key and get information about the current size of the underlying storage. The PluginStorage class interfaces with whatever storage backend Slack Machine is configured with. You can read more about the available storage backends in the user guide . Example: @respond_to ( r \"store (?P<text>.*) under (?P<key>\\w+)\" ) def store ( self , msg , text , key ): self . storage . set ( key , text ) msg . say ( \"' {} ' stored under {} !\" . format ( text , key )) @respond_to ( r \"retrieve (?P<key>\\w+)\" ) def retrieve ( self , msg , key ): data = self . storage . get ( key ) if data : msg . say ( \"' {} ' retrieved from < {} >!\" . format ( data , key )) else : msg . say ( \"Key not found!\" ) @respond_to ( r \"delete (?P<key>\\w+)\" ) def delete ( self , msg , key ): self . storage . delete ( key ) msg . say ( \"data in < {} > deleted!\" . format ( key )) @respond_to ( r \"does (?P<key>\\w+) exist?\" ) def exists ( self , msg , key ): # if key in self.storage if self . storage . has ( key ): msg . say ( \"< {} > exists.\" . format ( key )) else : msg . say ( \"< {} > does not exist!\" . format ( key )) @respond_to ( r \"size\" ) def size ( self , msg ): human_size = self . storage . get_storage_size_human () msg . say ( \"storage size: {} \" . format ( human_size ))","title":"Storage"},{"location":"plugins/storage/#shared-vs-non-shared","text":"By default, when you store, retrieve and remove data by key, Slack Machine will automatically namespace the keys you use with the fully qualified classname of the plugin the storage is used from. This is done to prevent plugins from changing or even deleting each others data. So when you do this: class MyPlugin : # resides in module my.plugin.package def some_function (): self . set ( 'my-key' , 'my-data' ) Slack Machine will send the key my.plugin.package.MyPlugin:my-key to the storage backend. You can override this behaviour by setting the shared parameter to True when calling a storage related function that requires a key as parameter. This keep the key global (ie. non-namespaced). This is useful when you want to share data between plugins. Use this feature with care though, as you can destroy data that belongs to other plugins!","title":"Shared vs non-shared"},{"location":"plugins/storage/#implementing-your-own-storage-backend","text":"You can implement your own storage backend by subclassing MachineBaseStorage . You only have to implement a couple of methods, and you don't have to take care of namespacing of keys, as Slack Machine will do that for you.","title":"Implementing your own storage backend"},{"location":"user/install/","text":"Installation This part of the documentation helps you install Slack Machine with the least amount of friction, or the most amount of flexibility. Installing the easy way with pip Slack Machine is published to the Python package index so you can easily install Slack Machine using pip: pip install slack-machine It is strongly recommended that you install slack-machine inside a virtual environment ! Installing from source If you are adventurous, want to modify the core of your Slack Machine instance and want maximum flexibility, you can also install from source. This way, you can enjoy the latest and greatest! You can either clone the public repository: git clone git://github.com/DandyDev/slack-machine.git Or, download the tarball : curl -OL https://github.com/DandyDev/slack-machine/tarball/main Optionally, zipball is also available (for Windows users). Once you have a copy of the source, you can embed it in your own Python package, or install it into your site-packages easily: cd slack-machine pip install .","title":"Installation"},{"location":"user/install/#installation","text":"This part of the documentation helps you install Slack Machine with the least amount of friction, or the most amount of flexibility.","title":"Installation"},{"location":"user/install/#installing-the-easy-way-with-pip","text":"Slack Machine is published to the Python package index so you can easily install Slack Machine using pip: pip install slack-machine It is strongly recommended that you install slack-machine inside a virtual environment !","title":"Installing the easy way with pip"},{"location":"user/install/#installing-from-source","text":"If you are adventurous, want to modify the core of your Slack Machine instance and want maximum flexibility, you can also install from source. This way, you can enjoy the latest and greatest! You can either clone the public repository: git clone git://github.com/DandyDev/slack-machine.git Or, download the tarball : curl -OL https://github.com/DandyDev/slack-machine/tarball/main Optionally, zipball is also available (for Windows users). Once you have a copy of the source, you can embed it in your own Python package, or install it into your site-packages easily: cd slack-machine pip install .","title":"Installing from source"},{"location":"user/intro/","text":"Introduction Philosophy Slack Machine is a sexy, simple, yet powerful and extendable bot platform for Slack. Slack Machine should be: Full-featured Easy to extend Easy to contribute to (the core) Fun to use Fun to extend My dream would be, that a community springs up around Slack Machine, that produces a myriad of useful plugins that are easy to install and use. Non-goals These are non-goals for me at the moment, but that might change in the future: Support for other backends than Slack Built-in AI. At least not in the core, although whatever intelligence developers put into their plugins, is cool of course Why Slack Machine was built I love Slack, and I use it on a daily basis, both at work and in my private life. Due to the powerful APIs that Slack exposes, it's not only great for chatting, but also for automation. We developers love automation, so I wanted to add some of that to the Slack teams I'm a member of. Obviously, there have already been many attempts to leverage this extensibility of Slack, considering the many bots/bot frameworks/chatops frameworks out there. Why build another one?! All of the options that I could find, were inadequate for some reason. I've used Hubot a lot in the past, but Coffeescript (or Javascript for that matter), just doesn't click with me. I personally feel that Python is a great language to tackle this sort of problem, so I started looking for Slack bots written in Python. At the time I created Slack Machine, these were the options I could find: python-rtmbot : Created by the Slack team, this bot is very barebones and exposes a very low-level plugin API. This makes it hard/tedious to write plugins for it. It is not mainainted anymore slackbot : Has a more high-level plugin API, which is built on the right ideas in terms of developer friendlyness. But it was lacking some features that I want in a bot (among other things: scheduling, persistent storage and a help-feature), and I found that the plugin architecture didn't allow for proper plugin organisation. This made me decide not to contribute, and instead start my own project. Will : This was originally not a bot for Slack, but for Hipchat. I'm including it anyways, because Will comes closests to what I want, both in terms of feature set and plugin API. At the time I created Slack Machine, it only supported HipChat ( for the time being , anyways), and I personally found the code quite hard to read. Update: Will now also supports Slack. But I feel that a framework specialized in a specific chat platforms is better than a framework trying to support different platforms. So, in the end I decided that writing a full-featured, easy-to-extend Slack bot, written in Python, would be cool new project to take up. Note The above was written 4 years ago and a lot has changed since then. The Slack team has created Bolt , a bot framework that is quite similar to Slack Machine. There are still differences in the way code is organized and I feel that Slack Machine is better suited to build complex Slack bots with in which code is organized in multiple plugins. I plan to keep maintaining Slack Machine and bringing it up to date with current best practices, so that the features and developer experience are on-par with or better than Bolt Acknowledgements Slack Machine owes a great deal of debt to the aforementioned packages. Parts of the API of Slack Machine were inspired by those packages, and I was at a great advantage while building Slack Machine because I was able to look at existing code to get an idea on how to approach certain problems. While obviously I'd like to think I have improved upon my inspirations, Slack Machine couldn't have existed without them. Slack Machine License MIT License Copyright (c) 2018 Daan Debie Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Introduction"},{"location":"user/intro/#introduction","text":"","title":"Introduction"},{"location":"user/intro/#philosophy","text":"Slack Machine is a sexy, simple, yet powerful and extendable bot platform for Slack. Slack Machine should be: Full-featured Easy to extend Easy to contribute to (the core) Fun to use Fun to extend My dream would be, that a community springs up around Slack Machine, that produces a myriad of useful plugins that are easy to install and use.","title":"Philosophy"},{"location":"user/intro/#non-goals","text":"These are non-goals for me at the moment, but that might change in the future: Support for other backends than Slack Built-in AI. At least not in the core, although whatever intelligence developers put into their plugins, is cool of course","title":"Non-goals"},{"location":"user/intro/#why-slack-machine-was-built","text":"I love Slack, and I use it on a daily basis, both at work and in my private life. Due to the powerful APIs that Slack exposes, it's not only great for chatting, but also for automation. We developers love automation, so I wanted to add some of that to the Slack teams I'm a member of. Obviously, there have already been many attempts to leverage this extensibility of Slack, considering the many bots/bot frameworks/chatops frameworks out there. Why build another one?! All of the options that I could find, were inadequate for some reason. I've used Hubot a lot in the past, but Coffeescript (or Javascript for that matter), just doesn't click with me. I personally feel that Python is a great language to tackle this sort of problem, so I started looking for Slack bots written in Python. At the time I created Slack Machine, these were the options I could find: python-rtmbot : Created by the Slack team, this bot is very barebones and exposes a very low-level plugin API. This makes it hard/tedious to write plugins for it. It is not mainainted anymore slackbot : Has a more high-level plugin API, which is built on the right ideas in terms of developer friendlyness. But it was lacking some features that I want in a bot (among other things: scheduling, persistent storage and a help-feature), and I found that the plugin architecture didn't allow for proper plugin organisation. This made me decide not to contribute, and instead start my own project. Will : This was originally not a bot for Slack, but for Hipchat. I'm including it anyways, because Will comes closests to what I want, both in terms of feature set and plugin API. At the time I created Slack Machine, it only supported HipChat ( for the time being , anyways), and I personally found the code quite hard to read. Update: Will now also supports Slack. But I feel that a framework specialized in a specific chat platforms is better than a framework trying to support different platforms. So, in the end I decided that writing a full-featured, easy-to-extend Slack bot, written in Python, would be cool new project to take up. Note The above was written 4 years ago and a lot has changed since then. The Slack team has created Bolt , a bot framework that is quite similar to Slack Machine. There are still differences in the way code is organized and I feel that Slack Machine is better suited to build complex Slack bots with in which code is organized in multiple plugins. I plan to keep maintaining Slack Machine and bringing it up to date with current best practices, so that the features and developer experience are on-par with or better than Bolt","title":"Why Slack Machine was built"},{"location":"user/intro/#acknowledgements","text":"Slack Machine owes a great deal of debt to the aforementioned packages. Parts of the API of Slack Machine were inspired by those packages, and I was at a great advantage while building Slack Machine because I was able to look at existing code to get an idea on how to approach certain problems. While obviously I'd like to think I have improved upon my inspirations, Slack Machine couldn't have existed without them.","title":"Acknowledgements"},{"location":"user/intro/#slack-machine-license","text":"MIT License Copyright (c) 2018 Daan Debie Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Slack Machine License"},{"location":"user/usage/","text":"Using Slack Machine Once you have installed Slack Machine, configuring and starting your bot is easy: Create a directory for your Slack Machine bot: mkdir my-slack-bot && cd my-slack-bot Add a local_settings.py file to your bot directory: touch local_settings.py Create a Bot User for your Slack team: https://my.slack.com/services/new/bot (take note of your API token) Add the Slack API token to your local_settings.py like this: local_settings.py SLACK_API_TOKEN = 'xox-my-slack-token' Start the bot with slack-machine ... Profit! Configuring Slack Machine All the configuration for your bot lives in the local_settings.py in the root of your bot directory. The core of Slack Machine, and the built-in plugins, only need a SLACK_API_TOKEN to function. You can override the log level by setting LOGLEVEL . By default this is set to \"ERROR\" . If you want to use Slack Machine behind a proxy, you can use HTTP_PROXY and HTTPS_PROXY . Be cautious, only http proxy is supported for now. If you find you have issues with Slack Machine disconnecting, try enabling the keep alive feature by setting KEEP_ALIVE to an integer (interval in seconds to send keep alive pings). Using environment variables for configuration For some configuration, it can be a security consideration not to store them in your source code (i.e. local_settings.py ) Slack Machine allows you to provide any setting - both built-in and for plugins - as environment variables. This is done by prefixing the setting name with SM_ . Example: SM_SLACK_API_TOKEN as environment variable can be used to set the SLACK_API_TOKEN setting instead of having to put it in the local_settings.py . Setting aliases The ALIASES configuration setting allows the bot to respond to a trigger symbol instead of a direct @botname. Example: If ALIASES='!,%' was set in local_settings.py then the bot would respond to the following phrases: @botname release the hounds !release the hounds %release the hounds Enabling plugins Slack Machine comes with a few simple built-in plugins: HelloPlugin : responds in kind when users greet the bot with \"hello\" or \"hi\" (only when the bot is mentioned) PingPongPlugin : responds to \"ping\" with \"pong\" and vice versa (listens regardless of mention) EchoPlugin : replies to any message the bot hears, with exactly the same message. The bot will reply to the same channel the original message was heard in HelpPlugin : responds to \"help\" with a list of all available commands and how they work. You can use \"robot help\" to learn the regexes that are used to match commands. MemePlugin : lets the user generate memes based on templates and captions Uses Memegen RBACPlugin : lets admins assign, revoke and list user roles. Is used when you want to protect commands By default, HelloPlugin and PingPonPlugin are enabled. You can specify which plugins Slack Machine should load, by setting the PLUGINS variable in local_settings.py to a list of fully qualified classes or modules that contain plugins. You can either point to a plugin class directly, or to a module containing one or more plugins. For example, to enable most of the built-in Slack Machine plugins, your local_settings.py would look like this: SLACK_API_TOKEN = 'xoxb-my-slack-token' PLUGINS = [ 'machine.plugins.builtin.general.PingPongPlugin' , 'machine.plugins.builtin.general.HelloPlugin' , 'machine.plugins.builtin.debug.EchoPlugin' , 'machine.plugins.builtin.fun.memes.MemePlugin' , 'machine.plugins.builtin.help.HelpPlugin' , ] Or is you want import them by the modules they're in: SLACK_API_TOKEN = 'xox-my-slack-token' PLUGINS = [ 'machine.plugins.builtin.general' , 'machine.plugins.builtin.debug' , 'machine.plugins.builtin.help' , 'machine.plugins.builtin.fun.memes' , ] Slack Machine can load any plugin that is on the Python path. This means you can load any plugin that is installed in the same virtual environment you installed Slack Machine in. And as a convenience, Slack Machine will also add the directory you start Slack Machine from, to your Python path. Choosing storage Slack Machine provides persistent storage, which can be used by plugins to store data of any kind. Slack Machine supports different backends for storage, so you can choose one that best fits your needs and existing infrastructure. You can configure which backend to use, by setting the STORAGE_BACKEND variable in local_settings.py to the fully qualified class of the chosen storage backend. Out of the box, Slack Machine provides 2 options for storage backend: in-memory ( default ): this backend will store all data in-memory, which is great for testing because it doesn't have any external dependencies. Does not persist data between restarts Class : machine.storage.backends.memory.MemoryStorage Redis : this backend stores data in Redis . Redis is a very fast key-value store that is super easy to install and operate. This backend is recommended, because it will persist data between restarts. The Redis backend requires you to provide a URL to your Redis instance by setting the REDIS_URL variable in local_settings.py . The URL should have the following format: redis:// : [/ ] Where db is optional and sets the database number ( 0 by default) Optional parameters: - `REDIS_MAX_CONNECTIONS`: maximum number of connections Slack Machine can make to your Redis instance - `REDIS_KEY_PREFIX`: the prefix Slack Machine uses for keys (`SM` by default, so \"key1\" gets stored under `SM:key1`) Class : machine.storage.backends.redis.RedisStorage So if, for example, you want to configure Slack Machine to use Redis as a storage backend, with your Redis instance running on localhost on the default port, you would add this to your local_settings.py : STORAGE_BACKEND = 'machine.storage.backends.redis.RedisStorage' REDIS_URL = redis : // localhost : 6379 ' That's all there is to it!","title":"Using Slack Machine"},{"location":"user/usage/#using-slack-machine","text":"Once you have installed Slack Machine, configuring and starting your bot is easy: Create a directory for your Slack Machine bot: mkdir my-slack-bot && cd my-slack-bot Add a local_settings.py file to your bot directory: touch local_settings.py Create a Bot User for your Slack team: https://my.slack.com/services/new/bot (take note of your API token) Add the Slack API token to your local_settings.py like this: local_settings.py SLACK_API_TOKEN = 'xox-my-slack-token' Start the bot with slack-machine ... Profit!","title":"Using Slack Machine"},{"location":"user/usage/#configuring-slack-machine","text":"All the configuration for your bot lives in the local_settings.py in the root of your bot directory. The core of Slack Machine, and the built-in plugins, only need a SLACK_API_TOKEN to function. You can override the log level by setting LOGLEVEL . By default this is set to \"ERROR\" . If you want to use Slack Machine behind a proxy, you can use HTTP_PROXY and HTTPS_PROXY . Be cautious, only http proxy is supported for now. If you find you have issues with Slack Machine disconnecting, try enabling the keep alive feature by setting KEEP_ALIVE to an integer (interval in seconds to send keep alive pings).","title":"Configuring Slack Machine"},{"location":"user/usage/#using-environment-variables-for-configuration","text":"For some configuration, it can be a security consideration not to store them in your source code (i.e. local_settings.py ) Slack Machine allows you to provide any setting - both built-in and for plugins - as environment variables. This is done by prefixing the setting name with SM_ . Example: SM_SLACK_API_TOKEN as environment variable can be used to set the SLACK_API_TOKEN setting instead of having to put it in the local_settings.py .","title":"Using environment variables for configuration"},{"location":"user/usage/#setting-aliases","text":"The ALIASES configuration setting allows the bot to respond to a trigger symbol instead of a direct @botname. Example: If ALIASES='!,%' was set in local_settings.py then the bot would respond to the following phrases: @botname release the hounds !release the hounds %release the hounds","title":"Setting aliases"},{"location":"user/usage/#enabling-plugins","text":"Slack Machine comes with a few simple built-in plugins: HelloPlugin : responds in kind when users greet the bot with \"hello\" or \"hi\" (only when the bot is mentioned) PingPongPlugin : responds to \"ping\" with \"pong\" and vice versa (listens regardless of mention) EchoPlugin : replies to any message the bot hears, with exactly the same message. The bot will reply to the same channel the original message was heard in HelpPlugin : responds to \"help\" with a list of all available commands and how they work. You can use \"robot help\" to learn the regexes that are used to match commands. MemePlugin : lets the user generate memes based on templates and captions Uses Memegen RBACPlugin : lets admins assign, revoke and list user roles. Is used when you want to protect commands By default, HelloPlugin and PingPonPlugin are enabled. You can specify which plugins Slack Machine should load, by setting the PLUGINS variable in local_settings.py to a list of fully qualified classes or modules that contain plugins. You can either point to a plugin class directly, or to a module containing one or more plugins. For example, to enable most of the built-in Slack Machine plugins, your local_settings.py would look like this: SLACK_API_TOKEN = 'xoxb-my-slack-token' PLUGINS = [ 'machine.plugins.builtin.general.PingPongPlugin' , 'machine.plugins.builtin.general.HelloPlugin' , 'machine.plugins.builtin.debug.EchoPlugin' , 'machine.plugins.builtin.fun.memes.MemePlugin' , 'machine.plugins.builtin.help.HelpPlugin' , ] Or is you want import them by the modules they're in: SLACK_API_TOKEN = 'xox-my-slack-token' PLUGINS = [ 'machine.plugins.builtin.general' , 'machine.plugins.builtin.debug' , 'machine.plugins.builtin.help' , 'machine.plugins.builtin.fun.memes' , ] Slack Machine can load any plugin that is on the Python path. This means you can load any plugin that is installed in the same virtual environment you installed Slack Machine in. And as a convenience, Slack Machine will also add the directory you start Slack Machine from, to your Python path.","title":"Enabling plugins"},{"location":"user/usage/#choosing-storage","text":"Slack Machine provides persistent storage, which can be used by plugins to store data of any kind. Slack Machine supports different backends for storage, so you can choose one that best fits your needs and existing infrastructure. You can configure which backend to use, by setting the STORAGE_BACKEND variable in local_settings.py to the fully qualified class of the chosen storage backend. Out of the box, Slack Machine provides 2 options for storage backend: in-memory ( default ): this backend will store all data in-memory, which is great for testing because it doesn't have any external dependencies. Does not persist data between restarts Class : machine.storage.backends.memory.MemoryStorage Redis : this backend stores data in Redis . Redis is a very fast key-value store that is super easy to install and operate. This backend is recommended, because it will persist data between restarts. The Redis backend requires you to provide a URL to your Redis instance by setting the REDIS_URL variable in local_settings.py . The URL should have the following format: redis:// : [/ ] Where db is optional and sets the database number ( 0 by default) Optional parameters: - `REDIS_MAX_CONNECTIONS`: maximum number of connections Slack Machine can make to your Redis instance - `REDIS_KEY_PREFIX`: the prefix Slack Machine uses for keys (`SM` by default, so \"key1\" gets stored under `SM:key1`) Class : machine.storage.backends.redis.RedisStorage So if, for example, you want to configure Slack Machine to use Redis as a storage backend, with your Redis instance running on localhost on the default port, you would add this to your local_settings.py : STORAGE_BACKEND = 'machine.storage.backends.redis.RedisStorage' REDIS_URL = redis : // localhost : 6379 ' That's all there is to it!","title":"Choosing storage"}]}